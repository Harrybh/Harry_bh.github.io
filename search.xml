<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「JSOI2008」球形空间产生器]]></title>
    <url>%2Fpost%2F%E3%80%8CJSOI2008%E3%80%8D%E7%90%83%E5%BD%A2%E7%A9%BA%E9%97%B4%E4%BA%A7%E7%94%9F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[对于每一个点我们都可以列出这样的方程 \sum_{j=1}^n(x_j-a_{ij})^2=R上下差为 \sum_{j=1}^n(x_j-a_{ij})^2-(x_j-a_{i+1j})^2=0 \sum_{j=1}^na_{ij}^2-a_{i+1j}^2-2a_{ij}x_j+2a_{i+1j}x_j=0所以每一项的系数为 $-x_j(2a_{ij}-2a_{i+1j})$ 常数项为 $\sum_{j=1}^n-a_{ij}^2+a_{i+1j}^2$ 共 $n$ 个未知数，$n$ 个方程高斯消元即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=10+5;double a[maxn][maxn];double p[maxn][maxn];int n;void gauss()&#123; for(int i=1;i&lt;=n;i++) &#123; int now=i; for(int j=i+1;j&lt;=n;j++)if(fabs(a[j][i])&gt;fabs(a[now][i]))now=j; if(now!=i)for(int j=i;j&lt;=n+1;j++)swap(a[now][j],a[i][j]); for(int k=i+1;k&lt;=n+1;k++) &#123; double t=a[k][i]/a[i][i]; for(int j=i;j&lt;=n+1;j++)a[k][j]-=a[i][j]*t; &#125; &#125; for(int i=n;i&gt;=1;i--) &#123; for(int j=i+1;j&lt;=n;j++) a[i][n+1]-=a[j][n+1]*a[i][j]; a[i][n+1]/=a[i][i]; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n+1;i++) for(int j=1;j&lt;=n;j++)scanf("%lf",&amp;p[i][j]); for(int i=1;i&lt;=n;i++) &#123; double tot=0; for(int j=1;j&lt;=n;j++) &#123; a[i][j]+=2*p[i][j]-2*p[i+1][j]; tot+=p[i][j]*p[i][j]-p[i+1][j]*p[i+1][j]; &#125; a[i][n+1]=tot; &#125; gauss(); for(int i=1;i&lt;=n;i++)printf("%.3lf ",a[i][n+1]); return 0; &#125;]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2016」游戏]]></title>
    <url>%2Fpost%2F%E3%80%8CSDOI2016%E3%80%8D%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[每次在路径上加的数是个一次函数，容易看出是树剖+李超线段树维护函数最小值。 我们需要构造一个坐标系然后就可以直接套李超线段树，不难发现我们可以把每个点的深度作为它的横坐标，那么一条重链上的点的横坐标都是连续的。 那么对于 $u\to LCA(u,v)$上的每个点 $i$ 纵坐标就是 $y=k(dis_u -dis_i)+b$ 所以我们相当于给$u\to LCA(u,v)$ 加上了一个 $y=kx+b$ 的直线 $k=-a$ ，$b=a\dot{} dis_u+b$ 那么对于 $v\to LCA(u,v)$上的每个点 $i$ 纵坐标就是 $y=k(dis_u+dis_i-2dis_{lca(u,v)})+b$ 同理相当于给$v\to LCA(u,v)$ 加上了一个 $y=kx+b$ 的直线 $k=a$ ，$b=a\dot{} (dis_u-2dis_{lca(u,v)})+b$ 直接维护就好了，要注意开始的时候每个点有一条 $k=0,b=inf$ 的直线，被这个坑了很久。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;const long long inf=123456789123456789LL;struct Seg&#123;long long k,b;&#125;;struct edge&#123;int v,nxt,w;&#125;e[maxn&lt;&lt;1];int top[maxn],siz[maxn],son[maxn],head[maxn],ecnt=0,fa[maxn],dfn[maxn],dep[maxn],idx=0;long long dis[maxn];int n,m;long long val[maxn];void add(int u,int v,int w)&#123; e[++ecnt]=(edge)&#123;v,head[u],w&#125;,head[u]=ecnt; e[++ecnt]=(edge)&#123;u,head[v],w&#125;,head[v]=ecnt;&#125;void dfs1(int u,int pre)&#123; siz[u]=1; dep[u]=dep[pre]+1,fa[u]=pre; for(int i=head[u];~i;i=e[i].nxt) &#123; int v=e[i].v; if(v==pre)continue; dis[v]=dis[u]+e[i].w; dfs1(v,u); siz[u]+=siz[v]; if(siz[son[u]]&lt;siz[v])son[u]=v; &#125;&#125;void dfs2(int u,int up)&#123; top[u]=up; dfn[u]=++idx; val[idx]=dis[u]; if(!son[u])return; dfs2(son[u],up); for(int i=head[u];~i;i=e[i].nxt) &#123; int v=e[i].v; if(v==fa[u]||v==son[u])continue; dfs2(v,v); &#125;&#125;Seg s[maxn&lt;&lt;2];//int hav[maxn&lt;&lt;2];long long minn[maxn&lt;&lt;2];void pushdown(int rt,int l,int r,Seg now)&#123;// if(!hav[rt])&#123;s[rt]=now;hav[rt]=1;return;&#125;巨大坑点 long long l1=now.k*val[l]+now.b,r1=now.k*val[r]+now.b; long long l2=s[rt].k*val[l]+s[rt].b,r2=s[rt].k*val[r]+s[rt].b; minn[rt]=min(minn[rt],min(l1,r1)); if(l1&gt;=l2&amp;&amp;r1&gt;=r2)return; if(l1&lt;=l2&amp;&amp;r1&lt;=r2)&#123;s[rt]=now;return;&#125; int mid=l+r&gt;&gt;1;double pos=(now.b-s[rt].b)/(s[rt].k-now.k); if(pos&lt;=val[mid])pushdown(rt&lt;&lt;1,l,mid,l1&lt;l2?now:s[rt]); else pushdown(rt&lt;&lt;1|1,mid+1,r,r1&lt;r2?now:s[rt]); if((l1&lt;l2&amp;&amp;pos&gt;=val[mid])||(r1&lt;r2&amp;&amp;pos&lt;val[mid]))s[rt]=now; minn[rt]=min(minn[rt],min(minn[rt&lt;&lt;1],minn[rt&lt;&lt;1|1]));&#125;void update(int rt,int l,int r,int L,int R,Seg now)&#123; //cout&lt;&lt;L&lt;&lt;' '&lt;&lt;R&lt;&lt;' '&lt;&lt;now.k&lt;&lt;' '&lt;&lt;now.b&lt;&lt;endl; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;pushdown(rt,l,r,now);return;&#125; int mid=l+r&gt;&gt;1; if(L&lt;=mid)update(rt&lt;&lt;1,l,mid,L,R,now); if(R&gt;mid)update(rt&lt;&lt;1|1,mid+1,r,L,R,now); minn[rt]=min(minn[rt],min(minn[rt&lt;&lt;1],minn[rt&lt;&lt;1|1]));&#125;void build(int rt,int l,int r)&#123; minn[rt]=inf; s[rt].b=inf; if(l==r)return; int mid=l+r&gt;&gt;1; build(rt&lt;&lt;1,l,mid),build(rt&lt;&lt;1|1,mid+1,r);&#125;long long query(int rt,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)return minn[rt]; long long ret=inf; if(s[rt].b!=inf) &#123; int ll=max(l,L),rr=min(r,R); ret=min(s[rt].k*val[ll],s[rt].k*val[rr])+s[rt].b; &#125; int mid=l+r&gt;&gt;1; if(L&lt;=mid)ret=min(ret,query(rt&lt;&lt;1,l,mid,L,R)); if(R&gt;mid)ret=min(ret,query(rt&lt;&lt;1|1,mid+1,r,L,R)); return ret;&#125;int lca(int u,int v)&#123; while(top[u]!=top[v]) &#123; if(dep[top[u]]&lt;dep[top[v]])swap(u,v); u=fa[top[u]]; &#125; return dep[u]&lt;dep[v]?u:v;&#125;void add(int u,int v,Seg t)&#123; while(top[u]!=top[v])update(1,1,n,dfn[top[u]],dfn[u],t),u=fa[top[u]]; update(1,1,n,dfn[v],dfn[u],t);&#125;long long ask(int u,int v)&#123; long long ans=inf; while(top[u]!=top[v]) &#123; if(dep[top[u]]&lt;dep[top[v]])swap(u,v); ans=min(ans,query(1,1,n,dfn[top[u]],dfn[u])); u=fa[top[u]]; &#125; if(dep[u]&gt;dep[v])swap(u,v); return min(ans,query(1,1,n,dfn[u],dfn[v]));&#125;int main()&#123; memset(head,-1,sizeof(head)); scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;n;i++) &#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add(u,v,w); &#125; dfs1(1,0); dfs2(1,1); build(1,1,n); //cout&lt;&lt;val[1]&lt;&lt;' '&lt;&lt;val[2]&lt;&lt;' '&lt;&lt;val[3]&lt;&lt;endl; while(m--) &#123; int op; scanf("%d",&amp;op); if(op==1) &#123; int u,v,a,b; scanf("%d%d%d%d",&amp;u,&amp;v,&amp;a,&amp;b); int t=lca(u,v); // cout&lt;&lt;t&lt;&lt;"haha"&lt;&lt;endl; add(u,t,(Seg)&#123;-a,a*1LL*dis[u]+b&#125;); add(v,t,(Seg)&#123;a,a*1LL*(dis[u]-dis[t]*2)+b&#125;); &#125; else &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); printf("%lld\n",ask(u,v)); &#125; &#125;// cout&lt;&lt;val[1]&lt;&lt;' '&lt;&lt;val[2]&lt;&lt;' '&lt;&lt;val[3]&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「学习笔记」李超线段树]]></title>
    <url>%2Fpost%2F%E3%80%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8D%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[「Heoi2013」 Segment有一个二维平面，你需要支持两种操作，插入一条线段，查询一条直线 $x=k$ 与其相交的最上面的一条线段。在学习之前离线做法可以用 $cdq$ 搞定，在线的话用平衡树也可以实现，李超树的做法相较于这两种要巧妙一些，核心的思想在于标记永久化维护覆盖区间中点的最高的线段。 考虑当前有一个线段树上的区间，要在这个区间里插入一条线段并维护答案，不妨分以下几类讨论： 如果当前这个区间还没有线段或者新加入的线段完全覆盖原来的线段，那么新加入的线段一定替换原来的线段 如果当前新加入的线段被原来的线段完全覆盖，那么这条新加入的线段一定不会再有用了。 将新加入的线段和原来的线段求交，将交所在的那半边较劣的线段下放到对应的儿子，更新区间中点的最高的线段。 此时维护的相当于是标记永久化的若干个线段，求答案就是将 $k$ 对应路径上的标记取最优线段，复杂度瓶颈所在的第三种情况每次都只会走一个儿子下放，所以从插入一条线段的复杂度是 $O(logn) $，由于要区间修改要在 $logn$ 个节点上插入线段，所以总复杂度 $O(nlogn)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e4+10;const double eps=1e-8;struct segment&#123;double k,b;int id;&#125;;segment s[maxn&lt;&lt;2];int hav[maxn&lt;&lt;2];void pushdown(int rt,int l,int r,segment now)&#123; if(!hav[rt])&#123;s[rt]=now;hav[rt]=1;return;&#125; double l1=now.k*l+now.b,r1=now.k*r+now.b; double l2=s[rt].k*l+s[rt].b,r2=s[rt].k*r+s[rt].b; if(l1&lt;=l2&amp;&amp;r1&lt;=r2)return ; if(l1&gt;=l2&amp;&amp;r1&gt;=r2)&#123;s[rt]=now;return;&#125; int mid=l+r&gt;&gt;1;double pos=(now.b-s[rt].b)/(s[rt].k-now.k); if(pos&lt;=mid)pushdown(rt&lt;&lt;1,l,mid,r1&gt;r2?s[rt]:now); else pushdown(rt&lt;&lt;1|1,mid+1,r,l1&gt;l2?s[rt]:now); if((l1&gt;l2&amp;&amp;pos&gt;=mid)||(r1&gt;r2&amp;&amp;pos&lt;mid))s[rt]=now;&#125;void update(int rt,int l,int r,int L,int R,segment now)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;pushdown(rt,l,r,now);return;&#125; int mid=l+r&gt;&gt;1; if(L&lt;=mid)update(rt&lt;&lt;1,l,mid,L,R,now); if(R&gt;mid)update(rt&lt;&lt;1|1,mid+1,r,L,R,now);&#125;segment query(int rt,int l,int r,int pos)&#123; if(l==r)return hav[rt]?s[rt]:(segment)&#123;0,0,0&#125;; int mid=l+r&gt;&gt;1;segment now; if(pos&lt;=mid)now=query(rt&lt;&lt;1,l,mid,pos); else now=query(rt&lt;&lt;1|1,mid+1,r,pos); if(!hav[rt])return now; double y1=pos*now.k+now.b,y2=s[rt].k*pos+s[rt].b; if(!now.id||(y1&lt;y2)||(fabs(y1-y2)&lt;eps&amp;&amp;s[rt].id&lt;now.id))now=s[rt]; return now;&#125;int n;int lim=39989;int lastans=0,tot=0;int main()&#123; scanf("%d",&amp;n); while(n--) &#123; int op; scanf("%d",&amp;op); if(op==0) &#123; int pos;scanf("%d",&amp;pos); pos=(pos+lastans-1)%lim+1; segment ans=query(1,1,lim,pos); printf("%d\n",lastans=ans.id); &#125; else &#123; int X0,X1,Y0,Y1; scanf("%d%d%d%d",&amp;X0,&amp;Y0,&amp;X1,&amp;Y1); X0=(X0+lastans-1)%lim+1,X1=(X1+lastans-1)%lim+1; Y0=(Y0+lastans-1)%(int)(1e9)+1,Y1=(Y1+lastans-1)%(int)(1e9)+1; if(X0&gt;X1)swap(X0,X1),swap(Y0,Y1); if(X0==X1)&#123;update(1,1,lim,X0,X1,(segment)&#123;0.0,1.0*max(Y0,Y1),++tot&#125;);continue;&#125; double k=1.0*(Y1-Y0)/(X1-X0),b=1.0*Y1-k*X1; update(1,1,lim,X0,X1,(segment)&#123;k,b,++tot&#125;); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
</search>
