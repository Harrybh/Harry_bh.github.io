<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网络流]]></title>
    <url>%2Fpost%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[一，网络流简介给定一个有向图 $G=(V,E)$，其中每一条边 $(u,v)$ 均有一个非负数的容量值，记为 $c(u,v)≥0$。同时在图中有两个特殊的顶点，源点 $S$ 和汇点 $T$。 其中节点1为源点$S$，节点6为汇点 $T$ 。 我们要求从源点 $S$ 到汇点 $T$ 的最大可行流量，这个问题也被称为最大流问题。 在这个例子中最大流量为 $5$，分别为：$1→2→4→6$，流量为$1$；$1→3→4→6$，流量为$2$；$1→3→5→6$，流量为$2$。 二，网络流的性质对于任意一个时刻，设 $f(u,v)$ 实际流量，则整个图 $G$ 的流网络满足3个性质： 容量限制：对任意 $u,v∈V，f(u,v)≤c(u,v)$。 反对称性：对任意 $u,v∈V，f(u,v) = -f(v,u)$。从 $u$ 到 $v$ 的流量一定是从 $v$ 到 $u$ 的流量的相反值。 流守恒性：对任意 $u$，若 $u$ 不为 $S$ 或 $T$，一定有 $∑f(u,v)=0，(u,v)∈E$。即 $u$ 到相邻节点的流量之和为0，因为流入 $u$ 的流量和 $u$ 点流出的流量相等，$u$ 点本身不会“制造”和“消耗”流量。 对于上面例子中的图，其对应的 $f$ 网络图为（其中虚线表示实际不存在的边 $(v,u)$ ）： 在此基础上，假设我们用 $cf(u,v)$ 来表示 $c(u,v)-f(u,v)$，则可以表示每一条边还剩下多少的流量可以使用，我们称为残留容量。 假设一条边 $(u,v)$，其容量为3，使用了流量 $f(u,v)=2$，则可以表示为：$cf(u,v)=1, cf(v,u)=2$。 由$cf(u,v)$构成的图我们称为残留网络。 比如例子中的残留网络图为： 既然残留网络表示还可以使用的流量，那么我就可以从图中找出一条从 $S$ 到 $T$ 的路径 $p$，使得路径 $p$ 上所有边的 $cf(u,v)$都大于0。 假设路径 $p$ 上最小的 $cf(u,v)$ 等于 $k$，那我就可以使得 $S$ 到 $T$ 增加 $k$ 的流量。 通过该条路径 $p$ 使得图G的最大流得到了增加，所以这样的路径 $p$ 被称为增广路径。 首先我根据读入的信息，就可以得到最初的图 $G$，然后将其转化为残留网络。 接下来我在残留网络上寻找是否有增广路径，如果不存在增广路径，则说明这个图不能再增加流量了。 若存在增广路径，则我将最大流量增加，同时对增广路径上的边 $cf(u,v)$ 进行修改，再重复寻找增广路径。 网络流求解最大流算法①（Ford-Fulkerson）伪代码: 1234while ( findAugmentPath() ) // 判断是否有增广路 maxFlow = maxFlow + delta // 最大流增加 modifyGraph() // 对增广路进行修改end while 时间复杂度方面，每一次寻找增广路的时间为 $O(n+m)$，每一次修改路径的时间复杂度为 $O(n)$。假设图的最大流为$maxflow$，那么我的算法时间复杂度为 $O((n+m)\times maxflow)$ 网络流求解最大流算法②（Dinic）每次建立分层图，然后进行多路增广。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950bool bfs()&#123; memset(dep,-1,sizeof(dep)); queue&lt;int&gt;q; dep[s]=0; q.push(s); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];~i;i=e[i].next) &#123; int v=e[i].v; if(e[i].w&gt;0&amp;&amp;dep[v]==-1) &#123; dep[v]=dep[u]+1; q.push(v); &#125; &#125; &#125; return dep[t]&gt;-1;&#125;long long dfs(int u,long long cap)&#123; if(u==t)return cap; long long flow=0; for(int i=head[u];~i;i=e[i].next) &#123; int v=e[i].v; if(e[i].w&amp;&amp;dep[v]==dep[u]+1) &#123; long long temp=dfs(v,min(cap-flow,e[i].w)); flow+=temp; e[i].w-=temp; e[i^1].w+=temp; if(flow==cap)return cap; &#125; &#125; if(!flow)dep[u]=-2;//小优化 return flow;&#125;long long dinic()&#123; long long f,ans=0; while(bfs()) &#123; while(f=dfs(s,inf))ans+=f; &#125; return ans;&#125; 复杂度 在所有边的容量都是1的图上：$O(min(V^{\frac{2}{3}},E^{\frac{1}{2}})E)$ 在存在一层容量都是1的分层图上：$O(E^{\frac{1}{2}}E)$ 在单位网络上：$O(V^{\frac{1}{2}}E)$ 一般情况下 $O(V^2E)$ 三，最大流最小割定理对于一个网络流图 $G=(V,E)$ ，其割的定义为一种点的划分方式：将所有的点划分为 $S$ 和 $T=V-S$ 两个部分，其中源点 $s∈S$，汇点 $t∈T$。 对于一个割 $(S,T)$，我们定义净流 $f(S,T) $表示穿过割 $(S,T) $ 的流量之和，即： f(S,T) = Σf(u,v) | u∈S,v∈T举个例子(该例子选自算法导论)： 净流f = f(2,4)+f(3,4)+f(3,5) = 12+(-4)+11 = 19同时我们定义割的容量 $C(S,T)$ 为所有从 $S$ 到 $T$ 的边容量之和，即： C(S,T) = Σc(u,v) | u∈S,v∈T同样在上面的例子中，其割的容量为： c(2,4)+c(3,5)=12+14=26实际上对于任意一个割的净流$f(S,T)$总是和网络流的流量 $f$ 相等。比如上面例子中我们改变一下割的方式： 可以计算出对于这两种情况净流 $f(S,T)$ 仍然等于19。 一个直观的解释是： 根据网络流的定义，只有源点 $s$ 会产生流量，汇点 $t$ 会接收流量。因此任意非 $s$ 和 $t$ 的点 $u$，其净流量一定为 $0$，也即是$Σf(u,v)=0$。而源点s的流量最终都会通过割$(S,T)$的边到达汇点 $t$，所以网络流的流$f$等于割的静流$f(S,T)$。 而在所有可能的割中，存在一个容量最小的割，我们称其为最小割。 这个最小割限制了一个网络的流 $f$ 上界，所以有： 对于任一个网络流图来说，其最大流一定是小于等于最小割的。 对于一个网络流图 $G=(V,E)$，其中有源点 $s$ 和汇点 $t$，那么下面三个条件是等价的： 流 $f$ 是图 $G$ 的最大流 残留网络 $Gf$ 不存在增广路 对于 $G$ 的某一个割 $(S,T)$，此时 $f = C(S,T)$ 首先证明1 =&gt; 2： 我们利用反证法，假设流 $f$ 是图 $G$ 的最大流，但是残留网络中还存在有增广路 $p$，其流量为 $fp$ 。则我们有流$f’=f+fp&gt;f$。这与 $f$ 是最大流产生矛盾。 接着证明2 =&gt; 3： 假设残留网络 $Gf$ 不存在增广路，所以在残留网络 $Gf$ 中不存在路径从 $s$ 到达 $t$。我们定义 $S$ 集合为：当前残留网络中 $s$ 能够到达的点。同时定义 $T=V-S$。此时 $(S,T)$ 构成一个割 $(S,T)$ 。且对于任意的 $u∈S,v∈T$，有 $f(u,v)=c(u,v)$。若 $f(u,v)0$ ，$s$ 可以到达 $v$，与 $v$ 属于 $T$ 矛盾。因此有$f(S,T)=Σf(u,v)=Σc(u,v)=C(S,T)$。 最后证明3 =&gt; 1： 由于$f$ 的上界为最小割，当 $f$ 到达割的容量时，显然就已经到达最大值，因此 $f $为最大流。 这样就说明了为什么找不到增广路时，所求得的一定是最大流。]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树套树]]></title>
    <url>%2Fpost%2F%E6%A0%91%E5%A5%97%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树套树是一种很暴力的数据结构，其实就是把各种树互相嵌套来在线维护一些普通数据结构不能维护的信息。 Ps:常数巨大能不用就不要用（CDQ分治，整体二分是个好东西） ①线段树套线段树一般是权值线段树套区间线段树（区间线段树套权值线段树） 可以用于离散化处理区间K小值 时间复杂度 $O(nlog_2^2n)$ 空间复杂度 $O(nlog_2^2n)$ 线段树需要动态开点 例题： BZOJ K大数查询 直接上权值线段树套区间线段树即可，注意题中权值范围 $≤n$ 所以不用离散化。 外层线段树写成 while 可以节省时间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=2e7+10;int idx=0;long long sum[maxn];int son[maxn][2];int tag[maxn];int root[maxn];int n,m;void pushup(int rt)&#123; sum[rt]=sum[son[rt][0]]+sum[son[rt][1]];&#125;void pushdown(int rt,int l,int r)&#123; if(!tag[rt])return; if(!son[rt][0])son[rt][0]=++idx; if(!son[rt][1])son[rt][1]=++idx; tag[son[rt][0]]+=tag[rt]; tag[son[rt][1]]+=tag[rt]; int mid=l+r&gt;&gt;1; sum[son[rt][0]]+=tag[rt]*1LL*(mid-l+1); sum[son[rt][1]]+=tag[rt]*1LL*(r-mid); tag[rt]=0;&#125;void update(int &amp;rt,int l,int r,int L,int R)&#123; if(!rt)rt=++idx; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; sum[rt]+=r-l+1; tag[rt]+=1; return ; &#125; int mid=l+r&gt;&gt;1; pushdown(rt,l,r); if(L&lt;=mid)update(son[rt][0],l,mid,L,R); if(R&gt;mid)update(son[rt][1],mid+1,r,L,R); pushup(rt);&#125;long long query(int rt,int l,int r,int L,int R)&#123; if(!rt)return 0; if(L&lt;=l&amp;&amp;r&lt;=R)return sum[rt]; int mid=l+r&gt;&gt;1; pushdown(rt,l,r); long long tot=0; if(L&lt;=mid)tot+=query(son[rt][0],l,mid,L,R); if(R&gt;mid)tot+=query(son[rt][1],mid+1,r,L,R); return tot;&#125;int Query(int L,int R,long long k)&#123; int l=1,r=n,rt=1; while(l!=r) &#123; int mid=l+r&gt;&gt;1; long long ans=query(root[rt&lt;&lt;1|1],1,n,L,R); if(ans&lt;k)k-=ans,r=mid,rt&lt;&lt;=1; else l=mid+1,rt=rt&lt;&lt;1|1; &#125; return l;&#125;void update(int L,int R,long long k)&#123; int l=1,r=n,rt=1; while(l!=r) &#123; int mid=l+r&gt;&gt;1; update(root[rt],1,n,L,R); if(k&lt;=mid)r=mid,rt&lt;&lt;=1; else l=mid+1,rt=rt&lt;&lt;1|1; &#125; update(root[rt],1,n,L,R);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); while(m--) &#123; int a,b; long long c; int op; scanf("%d%d%d%lld",&amp;op,&amp;a,&amp;b,&amp;c); if(op==1)update(a,b,c); else printf("%d\n",Query(a,b,c)); &#125;&#125; ②线段树套平衡树常数更大，TLE到崩溃 同线段树套线段树，只是更加灵活（当然动态开点线段树也很灵活） 一般的题只要有删除都需要写垃圾桶 就是把删除节点被编号记录下来重复利用（防止MLE） 例题： 二逼平衡树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235// luogu-judger-enable-o2#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,m;#define BUF_SIZE 100000#define OUT_SIZE 100000inline char nc()&#123; bool IOerror=0; static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if (p1==pend) &#123; p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if (pend==p1)&#123;IOerror=1;return -1;&#125; //&#123;printf("IO error!\n");system("pause");for (;;);exit(0);&#125; &#125; return *p1++;&#125;inline int read()&#123; char ch=nc();int x=0,f=1; while(!isdigit(ch))&#123;if(ch=='-') f=-1;ch=nc();&#125; while(isdigit(ch))&#123;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);ch=nc();&#125; return x*f;&#125;const int maxn=3e6+10;const int inf=2147483647;int son[maxn][2];int size[maxn];int val[maxn];int rnk[maxn];int root[maxn]; int idx=0;int valpos[maxn];inline void pushup(int rt)&#123; size[rt]=size[son[rt][0]]+size[son[rt][1]]+1;&#125;inline int newnode(int v)&#123; size[++idx]=1; val[idx]=v; rnk[idx]=rand(); return idx;&#125;void split(int rt,int k,int &amp;x,int &amp;y)&#123; if(!rt)x=y=0; else &#123; if(val[rt]&lt;=k)x=rt,split(son[rt][1],k,son[rt][1],y); else y=rt,split(son[rt][0],k,x,son[rt][0]); pushup(rt); &#125;&#125;int merge(int x,int y)&#123; if(!x||!y)return x+y; if(rnk[x]&lt;rnk[y]) &#123; son[x][1]=merge(son[x][1],y); pushup(x); return x; &#125; else &#123; son[y][0]=merge(x,son[y][0]); pushup(y); return y; &#125;&#125;inline int get_max(int rt)&#123; while(son[rt][1])rt=son[rt][1]; return rt==0?-inf:val[rt];&#125;inline int get_min(int rt)&#123; while(son[rt][0])rt=son[rt][0]; return rt==0?inf:val[rt];&#125;inline void insert(int v,int id)&#123; int x,y; split(root[id],v,x,y); root[id]=merge(merge(x,newnode(v)),y);&#125;inline int precursor(int v,int id)&#123; int x,y; split(root[id],v-1,x,y); int ans=get_max(x); root[id]=merge(x,y); return ans;&#125;inline int successor(int v,int id)&#123; int x,y; split(root[id],v,x,y); int ans=get_min(y); root[id]=merge(x,y); return ans;&#125;inline int rank(int v,int id)&#123; int x,y; split(root[id],v-1,x,y); int ans=size[x]; root[id]=merge(x,y); return ans;&#125;inline int rank2(int v,int id)&#123; int x,y; split(root[id],v,x,y); int ans=size[x]; root[id]=merge(x,y); return ans;&#125;inline void del(int v,int id)&#123; int x,y,z; split(root[id],v,x,z); split(x,v-1,x,y); y=merge(son[y][0],son[y][1]); root[id]=merge(merge(x,y),z);&#125;void update(int pos,int v,int to)&#123; int l=1,r=n,rt=1; while(l!=r) &#123; int mid=l+r&gt;&gt;1; del(v,rt); insert(to,rt); if(pos&lt;=mid)rt=rt&lt;&lt;1,r=mid; else rt=rt&lt;&lt;1|1,l=mid+1; &#125; del(v,rt); insert(to,rt);&#125;int Queryrank(int l,int r,int L,int R,int rt,int k)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)return rank(k,rt); int mid=l+r&gt;&gt;1; int ans=0; if(L&lt;=mid)ans+=Queryrank(l,mid,L,R,rt&lt;&lt;1,k); if(R&gt;mid)ans+=Queryrank(mid+1,r,L,R,rt&lt;&lt;1|1,k); return ans;&#125;int Queryrank2(int l,int r,int L,int R,int rt,int k)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)return rank2(k,rt); int mid=l+r&gt;&gt;1; int ans=0; if(L&lt;=mid)ans+=Queryrank2(l,mid,L,R,rt&lt;&lt;1,k); if(R&gt;mid)ans+=Queryrank2(mid+1,r,L,R,rt&lt;&lt;1|1,k); return ans;&#125;int Querypre(int l,int r,int L,int R,int rt,int k)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)return precursor(k,rt); int mid=l+r&gt;&gt;1; if(R&lt;=mid)return Querypre(l,mid,L,R,rt&lt;&lt;1,k); if(L&gt;mid)return Querypre(mid+1,r,L,R,rt&lt;&lt;1|1,k); return max(Querypre(l,mid,L,R,rt&lt;&lt;1,k),Querypre(mid+1,r,L,R,rt&lt;&lt;1|1,k));&#125;int Querysuc(int l,int r,int L,int R,int rt,int k)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)return successor(k,rt); int mid=l+r&gt;&gt;1; if(R&lt;=mid)return Querysuc(l,mid,L,R,rt&lt;&lt;1,k); if(L&gt;mid)return Querysuc(mid+1,r,L,R,rt&lt;&lt;1|1,k); return min(Querysuc(l,mid,L,R,rt&lt;&lt;1,k),Querysuc(mid+1,r,L,R,rt&lt;&lt;1|1,k));&#125;void build(int l,int r,int rt)&#123; for(int i=l;i&lt;=r;i++)insert(valpos[i],rt); if(l==r)return; int mid=l+r&gt;&gt;1; build(l,mid,rt&lt;&lt;1); build(mid+1,r,rt&lt;&lt;1|1);&#125;int main()&#123; srand(20021112); n=read(),m=read(); int MAX=0,Min=0x3f3f3f3f; for(int i=1;i&lt;=n;i++)valpos[i]=read(),MAX=max(MAX,valpos[i]),Min=min(Min,valpos[i]); build(1,n,1); while(m--) &#123; int l,r,k,op; op=read(); if(op==1) &#123; l=read(),r=read(),k=read(); printf("%d\n",Queryrank(1,n,l,r,1,k)+1); &#125; else if(op==2) &#123; l=read(),r=read(),k=read(); int L=0,R=MAX,ans=-1; while(L&lt;=R) &#123; int mid=L+R&gt;&gt;1; if(Queryrank2(1,n,l,r,1,mid)&gt;=k)R=mid-1,ans=mid; else L=mid+1; &#125; printf("%d\n",ans); &#125; else if(op==3) &#123; MAX=max(MAX,k); Min=min(Min,k); l=read(),k=read(); update(l,valpos[l],k); valpos[l]=k; &#125; else if(op==4) &#123; l=read(),r=read(),k=read(); printf("%d\n",Querypre(1,n,l,r,1,k)); &#125; else &#123; l=read(),r=read(),k=read(); printf("%d\n",Querysuc(1,n,l,r,1,k)); &#125; &#125; return 0;&#125; ③ 平衡树套各种神奇的数据结构很多题目中要求支持插入操作，所以需要平衡树，但是有需要询问一些诡异的东西。 如果是常规的平衡树（旋转）每次pushup时间开销巨大，所以需要使用不旋转的平衡树（替罪羊树） 但是我不会替罪羊树 但是没有什么是分块不能解决的。 把平衡树替换成块状链表就行了 例题： ALOEXT 平衡树套Trie，但是我嫌麻烦，就写了块状链表套Trie 跑的比平衡树快多了，内存开销也很小。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e6+10;const int maxl=2e3+500;struct Trie&#123; int son[2],size;&#125;tr[maxn];int tireuse=0;int insert_num(int rt,int x,int cnt)&#123; if(!rt)rt=++tireuse; int u=rt; for(int i=19;i&gt;=0;i--) &#123; bool c=x&amp;(1&lt;&lt;i); tr[u].size+=cnt; if(!tr[u].son[c])tr[u].son[c]=++tireuse; u=tr[u].son[c]; &#125; tr[u].size+=cnt; return rt;&#125;int query_num(int u,int x)&#123; int ans=0; for(int i=19;i&gt;=0;i--) &#123; bool c=x&amp;(1&lt;&lt;i); if(tr[tr[u].son[1-c]].size)u=tr[u].son[1-c],ans+=(1&lt;&lt;i); else u=tr[u].son[c]; &#125; return ans;&#125;struct block_list&#123; int root,cnt,nxt; int max1,max2,seq[maxl*4+5]; block_list() &#123; root=cnt=nxt=max1=max2=0; memset(seq,0,sizeof(seq)); &#125; void get_max() &#123; max1=max2=0; for(int i=1;i&lt;=cnt;i++) if(max1&lt;seq[i])max2=max1,max1=seq[i]; else if(max2&lt;seq[i])max2=seq[i]; &#125;&#125;b[400];int use=1;void change(int pos,int v)&#123; for(int i=1;i;i=b[i].nxt) if(b[i].cnt&gt;=pos) &#123; b[i].root=insert_num(b[i].root,b[i].seq[pos],-1); b[i].seq[pos]=v; insert_num(b[i].root,b[i].seq[pos],1); b[i].get_max(); return ; &#125; else pos-=b[i].cnt;&#125;void cut(int u)&#123; int v=++use; b[u].cnt=b[v].cnt=maxl*2; b[v].nxt=b[u].nxt; b[u].nxt=v; for(int i=1;i&lt;=maxl*2;i++) &#123; b[v].seq[i]=b[u].seq[i+maxl*2]; b[u].seq[i+maxl*2]=0; &#125; b[u].get_max(); b[v].get_max(); b[u].root=insert_num(0,b[u].seq[1],1); b[v].root=insert_num(0,b[v].seq[1],1); for(int i=2;i&lt;=maxl*2;i++) &#123; insert_num(b[u].root,b[u].seq[i],1); insert_num(b[v].root,b[v].seq[i],1); &#125; return ; &#125;void insert(int pos,int v)&#123; int pre=0,i; for(i=1;i;i=b[i].nxt) if(b[i].cnt&gt;=pos)break; else pos-=b[i].cnt,pre=i; if(!i)i=pre,pos=b[i].cnt+pos; for(int j=b[i].cnt;j&gt;=pos;j--)b[i].seq[j+1]=b[i].seq[j]; b[i].seq[pos]=v; b[i].cnt++; b[i].root=insert_num(b[i].root,v,1); if(v&gt;b[i].max1)b[i].max2=b[i].max1,b[i].max1=v; else if(v&gt;b[i].max2)b[i].max2=v; if(b[i].cnt&gt;=maxl*4)cut(i); return ; &#125;void del(int pos)&#123; int pre=1,i; for(i=1;i;i=b[i].nxt) if(b[i].cnt&gt;=pos)break; else pos-=b[i].cnt,pre=i; int tmp=b[i].seq[pos]; insert_num(b[i].root,tmp,-1); for(int j=pos;j&lt;=b[i].cnt;j++)b[i].seq[j]=b[i].seq[j+1]; b[i].cnt--; if(b[i].cnt==0) &#123; b[pre].nxt=b[i].nxt; return ; &#125; if(b[i].max2&gt;tmp)return; b[i].get_max(); return ;&#125;inline void cmp(int &amp;a,int &amp;b,int c)&#123; if(c&gt;a)b=a,a=c; else if(c&gt;b)b=c; return;&#125;int getmax(int L,int R)&#123; int max1=0,max2=0,now=0; for(int i=1;i;i=b[i].nxt) &#123; if(L&lt;=now+1&amp;&amp;now+b[i].cnt&lt;=R) &#123; cmp(max1,max2,b[i].max1); cmp(max1,max2,b[i].max2); &#125; else if(now+1&lt;=L&amp;&amp;R&lt;=now+b[i].cnt) &#123; for(int j=L-now;j&lt;=R-now;j++) cmp(max1,max2,b[i].seq[j]); &#125; else if(now+1&lt;=L&amp;&amp;L&lt;=now+b[i].cnt) &#123; for(int j=L-now;j&lt;=b[i].cnt;j++) cmp(max1,max2,b[i].seq[j]); &#125; else if(now+1&lt;=R&amp;&amp;R&lt;=now+b[i].cnt) &#123; for(int j=1;j&lt;=R-now;j++) cmp(max1,max2,b[i].seq[j]); &#125; now+=b[i].cnt; &#125; return max2;&#125;int query(int L,int R)&#123; int mid=getmax(L,R),now=0,ans=0; for(int i=1;i;i=b[i].nxt) &#123; if(L&lt;=now+1&amp;&amp;now+b[i].cnt&lt;=R) &#123; ans=max(ans,query_num(b[i].root,mid)); &#125; else if(now+1&lt;=L&amp;&amp;R&lt;=now+b[i].cnt) &#123; for(int j=L-now;j&lt;=R-now;j++) ans=max(ans,mid^b[i].seq[j]); &#125; else if(now+1&lt;=L&amp;&amp;L&lt;=now+b[i].cnt) &#123; for(int j=L-now;j&lt;=b[i].cnt;j++) ans=max(ans,mid^b[i].seq[j]); &#125; else if(now+1&lt;=R&amp;&amp;R&lt;=now+b[i].cnt) &#123; for(int j=1;j&lt;=R-now;j++) ans=max(ans,mid^b[i].seq[j]); &#125; now+=b[i].cnt; &#125; return ans;&#125;int n,m,last=0,now=0;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; int tmp; scanf("%d",&amp;tmp); insert(i,tmp); &#125; now=n; while(m--) &#123; char c[5]; int x,y; scanf("%s%d",c,&amp;x); x=(x+last)%now+1; if(c[0]=='D') &#123; del(x); now--; continue; &#125; scanf("%d",&amp;y); if(c[0]=='F')y=(y+last)%now+1; else y=(y+last)%1048576; if(c[0]=='I')insert(x,y),now++; if(c[0]=='C')change(x,y); if(c[0]=='F')printf("%d\n",last=query(min(x,y),max(x,y))); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整体二分]]></title>
    <url>%2Fpost%2F%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[若询问满足可二分性，且修改操作不互相干扰，支持离线就可以使用整体二分 首先确定一个决策区间 $solve(l, r, L, R)$ 表示编号在 $L\to R$ 的操作的数的权值和询问的答案在 $l \to r$ 这个区间，每次将答案二分，把 $L,R$ 里的修改操作按被修改数的权值 $&lt;=mid$ 和$&gt;mid$ 分成左右两边，如果 $&lt;=mid$，就把它下标所在位置在bit里 $+1$ ，把 $L,R$里的查询操作按bit上查询区间里的 $sum&gt;=k$ 和 $&lt;k$ 分成左右两边，如果 $&lt;k$ ，那么 $k$ 就要减去bit上查询区间里的 $sum$ ，然后就按丢到左右两边的操作分治就好了。 很简单易懂 例题： K大数查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=5e4+10;const int inf=1e9+10;#define int long long struct item&#123; int L,R,k,id,ty;&#125;a[maxn],tmp1[maxn],tmp2[maxn];int n,m;long long ans[maxn];long long sum[maxn&lt;&lt;2];long long tag[maxn&lt;&lt;2];void pushup(int rt)&#123;sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];&#125;void pushdown(int rt,int l,int r)&#123; if(!tag[rt])return; int mid=l+r&gt;&gt;1; sum[rt&lt;&lt;1]+=tag[rt]*(mid-l+1),sum[rt&lt;&lt;1|1]+=tag[rt]*(r-mid); tag[rt&lt;&lt;1]+=tag[rt],tag[rt&lt;&lt;1|1]+=tag[rt]; tag[rt]=0;&#125;void update(int L,int R,int l,int r,int rt,int v)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; sum[rt]+=v*(r-l+1); tag[rt]+=v; return; &#125; int mid=l+r&gt;&gt;1; pushdown(rt,l,r); if(L&lt;=mid)update(L,R,l,mid,rt&lt;&lt;1,v); if(R&gt;mid)update(L,R,mid+1,r,rt&lt;&lt;1|1,v); pushup(rt);&#125;long long query(int L,int R,int l,int r,int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)return sum[rt]; int mid=l+r&gt;&gt;1; pushdown(rt,l,r); long long ans=0; if(L&lt;=mid)ans+=query(L,R,l,mid,rt&lt;&lt;1); if(R&gt;mid)ans+=query(L,R,mid+1,r,rt&lt;&lt;1|1); return ans;&#125;void solve(int l,int r,int L,int R)&#123; if(l&gt;r||L&gt;R)return; if(l==r) &#123; for(int i=L;i&lt;=R;i++)if(a[i].ty)ans[a[i].id]=n-l+1; return; &#125; int mid=l+r&gt;&gt;1; int cnt1=0,cnt2=0; for(int i=L;i&lt;=R;i++) if(a[i].ty) &#123; int delta=query(a[i].L,a[i].R,1,n,1); if(a[i].k&lt;=delta)tmp1[++cnt1]=a[i]; else a[i].k-=delta,tmp2[++cnt2]=a[i]; &#125; else &#123; if(a[i].k&lt;=mid)tmp1[++cnt1]=a[i],update(a[i].L,a[i].R,1,n,1,1); else tmp2[++cnt2]=a[i]; &#125; for(int i=1;i&lt;=cnt1;i++)if(tmp1[i].ty==0)update(tmp1[i].L,tmp1[i].R,1,n,1,-1); for(int i=1;i&lt;=cnt1;i++)a[i+L-1]=tmp1[i]; for(int i=1;i&lt;=cnt2;i++)a[cnt1+L+i-1]=tmp2[i]; solve(l,mid,L,L+cnt1-1); solve(mid+1,r,L+cnt1,R);&#125;#undef intint main()&#123; int tot=0; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; long long type,x,y; long long k; scanf("%lld%lld%lld%lld",&amp;type,&amp;x,&amp;y,&amp;k); if(type==2)a[i]=(item)&#123;x,y,k,++tot,1&#125;; else a[i]=(item)&#123;x,y,n-k+1,i,0&#125;; &#125; solve(1,n,1,m); for(int i=1;i&lt;=tot;i++)printf("%lld\n",ans[i]); //system("pause");&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCT(Link-Cut-Tree)]]></title>
    <url>%2Fpost%2FLCT-Link-Cut-Tree%2F</url>
    <content type="text"><![CDATA[LCT是一种用来解决动态树（树的形态会发生变化）问题的数据结构 下面我们用道题来引入这种数据结构 给定n个点以及每个点的权值，要你处理接下来的 $m$ 个操作。操作有 $4$ 种。操作从 $0$ 到 $3$编号。点从 $1$ 到 $n$ 编号。 0：后接两个整数 $(x，y)$，代表询问从 $x$ 到 $y$ 的路径上的点的权值的 $xor$ 和。保证 $x$ 到 $y$ 是联通的。 1：后接两个整数 $(x，y)$，代表连接 $x$ 到 $y$，若 $x$ 到 $y$ 已经联通则无需连接。 2：后接两个整数 $(x，y)$，代表删除边 $(x，y)$，不保证边 $(x，y)$ 存在 3：后接两个整数 $(x，y)$，代表将点 $x$ 上的权值变成 $y$。 如果没有 1，2 操作那么这道题是裸的树链剖分。 但是正因为 1，2 操作存在，所以这道题需要使用专门用于解决这类问题的LCT来 $solve$ . 首先为了便于理解，我先讲讲 LCT 的简单思路（如果要获取更加详细的讲解，可以参考网上博客） 我们使用 很多棵splay来维护一条条链 关于链怎么得到，我们采用 实链剖分 在实链剖分时，选择结点 $u$ 一个儿子 $v$ 作为重儿子，把连接这两个节点的边 $(u,v)$ 作为重边（下图中加粗的边），连接其他儿子的边作为轻边。 而且这个链是动态的 那么对于连续的重边（如 $(c,g) (g,h) (h,j)$）我们就用同一颗splay来维护 每棵splay中都至少含有1个结点 （下图需要 7 棵splay，应该没数错） 那么这样一棵树就被分成了很多棵splay来维护 那么对于一棵splay我们怎么维护一条链呢? 首先我们可以看出对于一个结点 $u$ 只有一个儿子和它在同一个splay中（或者它没有儿子），父亲 $fa$ 和它在同一个splay中（或者不在） 所以同一条链上的每个节点深度都是不同的 那么我们就可以这样来维护splay 性质： 对于一个splay中的点 $x$ 它在原图中代表点 $u$ ，那么 $x$ 的左儿子一定是比 $u$ 深度小的点，或者没有左儿子 那么 $x$ 的右儿子一定是比 $u$ 深度大的点，或者没有右儿子 按照上面的方法 CGHJ 这几个点组成的splay是这样的 然后如果我们要查询一条链内的信息就是splay的区间操作了 而且显而易见，因为splay无论怎么变化，它的中序遍历始终不会发生改变（这个不了解的话在去学习一下splay吧） 所以即使splay形态改变依然满足上面的那个性质 那么现在我们就是要考虑，splay与splay之间的关系 首先我们可以看到在原图链与链之间也是有一定联系的，比如 D 链的上方是 ABE 链 CGHJ 链的上方是 ABE 链 那么在splay中splay的根节点的父亲 $fa[root]=$ 链上方的节点 如 $fa[root_{CGHJ}]= A，fa[root_{KI}]= H$ 而不是原来普通splay的 $0$ 这样就很方便我们从一颗splay跳跃到上方的splay 因为原图的splay有了父子关系，所以我们可以大致得出原图每个splay的关系和形态 其中虚线表示的是，父子关系，每一个方框中是一颗splay（观察发现是不是splay的形态满足上面的性质呢？） 现在我们已经大致了解了LCT的思路 我们再进行一次总结 ①多棵splay维护，每棵splay维护一条链。 ②对于一个splay中的点 $x$ 它在原图中代表点 $u$ ，那么 $x$ 的左儿子一定是比 $u$ 深度小的点 或者没有左儿子 ，那么 $x$ 的右儿子一定是比 $u$ 深度大的点，或者没有右儿子 ③在splay中，splay的根节点的父亲 ，$fa[root]=$ 链上方的节点 看了前面的思路，你可能有很多疑问： 为什么么要这样搞啊？ 什么鬼？ 这样好麻烦，能不能简洁点？ 接下来就是splay的操作部分，详细看完了这些你就能大致了解LCT。 点这里 ：【CSDN】这个博客对于操作讲的很不错 请先阅读完上面的内容 我这里主要讲讲一些难以理解的地方（对代码进行讲解） 以下采用数组写法 Splay 的定义1int son[maxn][2],fa[maxn],rev[maxn],sum[maxn],val[maxn]; son[][0/1] ：节点的左右儿子. fa[] ：splay上每个点的父亲，根的父亲为另外一棵splay rev[] ：splay区间翻转标记 作用是支持 make_root 操作 sum[] ：区间异或和 val[] ：点的权值 Splay的基本操作1234567891011121314151617181920212223242526272829303132333435363738394041bool isroot(int rt)&#123; return (son[fa[rt]][0]!=rt)&amp;&amp;(son[fa[rt]][1]!=rt);&#125;//检查rt是否为splay的根，如果是那么它的父亲的左右儿子都不等于它，因为它的父亲在另一棵splay中。void pushup(int rt)&#123; sum[rt]=sum[son[rt][0]]^sum[son[rt][1]]^val[rt];&#125;//splay统计左右子树异或和void Rev(int rt)&#123; swap(son[rt][0],son[rt][1]),rev[rt]^=1;&#125;//splay翻转操作，作用是将左右儿子交换void pushdown(int rt)&#123; if(rev[rt])Rev(son[rt][0]),Rev(son[rt][1]),rev[rt]=0;&#125;//splay下传翻转标记void relax(int rt)&#123; if(!isroot(rt))relax(fa[rt]); pushdown(rt);&#125;//在splay操作时释放标记（先释放，在splay操作）void rotate(int rt)&#123; int f=fa[rt],g=fa[f]; int nf=son[f][1]==rt,ng=son[g][1]==f; fa[son[rt][nf^1]]=f,son[f][nf]=son[rt][nf^1]; fa[rt]=g;if(!isroot(f))son[g][ng]=rt; fa[f]=rt,son[rt][nf^1]=f; pushup(f),pushup(rt);&#125;//旋转操作，但是要注意如果要旋转的节点的父亲是根，那么父亲的父亲和父亲没有父子关系（因为他们不在同一棵splay中）void splay(int rt)&#123; relax(rt); while(!isroot(rt)) &#123; int f=fa[rt],g=fa[f]; if(!isroot(f)) (son[f][0]==rt)^(son[g][0]==f)?rotate(rt):rotate(f); rotate(rt); &#125;&#125;//先释放标记，在将rt旋转到对应的splay的根节点 Access123456789void access(int rt)&#123; for(int y=0;rt;rt=fa[rt])splay(rt),fa[son[rt][1]=y]=rt,pushup(rt),y=rt;&#125;//将rt到原树上的根的路径上的点放入一棵splay中//①将当前点旋转到根//②将当前点的右儿子设置成上一次的splay的根//③将上一次的splay的根的父亲置为当前点//④处理当前点的父亲，进入另外一棵splay Makeroot1234void makeroot(int rt)&#123; access(rt),splay(rt),Rev(rt);&#125;//将rt到原树的根路径上的点放入一棵splay中，然后将当前点旋转到根，然后翻转操作 这里有个疑难点，Makeroot操作会使得树的形态改变，但是不影响实际结果 因为我们这个是动态树啊，而且即使儿子改变，但是实际的父亲还是没有发生改变，所以树实际没有变化。 modify12345void modify(int rt,int v)&#123; val[rt]=v; splay(rt);&#125;//直接修改点权，然后进行splay（经典操作） findroot123456int findroot(int rt)&#123; access(rt),splay(rt); for(;son[rt][0];rt=son[rt][0]); return rt;&#125;//将rt到原树的根路径上的点放入一棵splay中，然后将当前点旋转到根，然后找到最右边的点（深度最小的点），即为根 Link1234void link(int a,int b)&#123; if(findroot(a)!=findroot(b))makeroot(a),fa[a]=b;&#125;//先检查a，b在不在同一棵树中，如果不在，就将a的父亲置为b Cut12345void cut(int a,int b)&#123; makeroot(a),access(b),splay(b); if(son[b][0]==a)son[b][0]=fa[a]=0;&#125;//先将a变成根，将b到原树的根路径上的点放入一棵splay中，然后将b点旋转到splay根，如果说，b的上边的点是a，就断开b与a的关系。 Query12345int query(int a,int b)&#123; makeroot(a),access(b),splay(b); return sum[b];&#125;//将a,b放在同一棵splay中，并且将b作为splay的根，然后统计答案 对于原树，我们可以通过多次（$n-1$） $Link(u,v)$ 操作，构造出原树的LCT ​ by Harry_Bh 最上面的例题AC代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=3e5+10;int n,m;inline int read()&#123; int f=1,x=0;char ch; do&#123;ch=getchar();if(ch=='-')f=-1;&#125;while(ch&lt;'0'||ch&gt;'9'); do&#123;x=x*10+ch-'0';ch=getchar();&#125;while(ch&gt;='0'&amp;&amp;ch&lt;='9'); return f*x;&#125;struct LCT&#123; int son[maxn][2],fa[maxn],rev[maxn],sum[maxn],val[maxn]; bool isroot(int rt) &#123; return (son[fa[rt]][0]!=rt)&amp;&amp;(son[fa[rt]][1]!=rt); &#125; void pushup(int rt) &#123; sum[rt]=sum[son[rt][0]]^sum[son[rt][1]]^val[rt]; &#125; void Rev(int rt) &#123; swap(son[rt][0],son[rt][1]),rev[rt]^=1; &#125; void pushdown(int rt) &#123; if(rev[rt])Rev(son[rt][0]),Rev(son[rt][1]),rev[rt]=0; &#125; void relax(int rt) &#123; if(!isroot(rt))relax(fa[rt]); pushdown(rt); &#125; void rotate(int rt) &#123; int f=fa[rt],g=fa[f]; int nf=son[f][1]==rt,ng=son[g][1]==f; fa[son[rt][nf^1]]=f,son[f][nf]=son[rt][nf^1]; fa[rt]=g;if(!isroot(f))son[g][ng]=rt; fa[f]=rt,son[rt][nf^1]=f; pushup(f),pushup(rt); &#125; void splay(int rt) &#123; relax(rt); while(!isroot(rt)) &#123; int f=fa[rt],g=fa[f]; if(!isroot(f)) (son[f][0]==rt)^(son[g][0]==f)?rotate(rt):rotate(f); rotate(rt); &#125; &#125; void access(int rt) &#123; for(int y=0;rt;rt=fa[rt])splay(rt),fa[son[rt][1]=y]=rt,pushup(rt),y=rt; &#125; void makeroot(int rt) &#123; access(rt),splay(rt),Rev(rt); &#125; void modify(int rt,int v) &#123; val[rt]=v; splay(rt); &#125; int findroot(int rt) &#123; access(rt),splay(rt); for(;son[rt][0];rt=son[rt][0]); return rt; &#125; void link(int a,int b) &#123; if(findroot(a)!=findroot(b))makeroot(a),fa[a]=b; &#125; void cut(int a,int b) &#123; makeroot(a),access(b),splay(b); if(son[b][0]==a)son[b][0]=fa[a]=0; &#125; int query(int a,int b) &#123; makeroot(a),access(b),splay(b); return sum[b]; &#125;&#125;Tr;int u,v,op;int main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++)Tr.modify(i,read()); for(int i=1;i&lt;=m;i++) &#123; op=read(),u=read(),v=read(); if(op==0)printf("%d\n",Tr.query(u,v)); else if(op==1)Tr.link(u,v); else if(op==2)Tr.cut(u,v); else Tr.modify(u,v); &#125; return 0;&#125; 原谅我丑陋的代码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CDQ分治]]></title>
    <url>%2Fpost%2FCDQ%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[CDQ分治主要思想 我们要解决一系列问题，这些问题一般包含修改和查询操作，可以把这些问题排成一个序列，用一个区间[L,R]表示。 分。递归处理左边区间[L,M]和右边区间[M+1,R]的问题。 治。合并两个子问题，同时考虑到[L,M]内的修改对[M+1,R]内的查询产生的影响。即，用左边的子问题帮助解决右边的子问题。 典型的例题就是归并排序求解逆序对。 简而言之就是用来对多维偏序问题进行降维处理。 给定 N 个有序对 $(a,b)$，求对于每个$(a,b)$，满足$a_2&lt;a$且$b_2&lt;b$的有序对$(a_2,b_2)$有多少个 比如二位偏序问题，可以直接对 a 排序后使用CDQ分治，因为 a 已经有序了，所以左边的 a 一定比右边的 a 小，所以直接统计 b 就行了。 每个维度可以使用数据结构或者CDQ分治求解 多维偏序则可以CDQ分治互相嵌套 三维偏序例题： 陌上花开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=2e5+10;struct Query&#123; int x,y,id,pos,z; bool operator &lt; (const Query &amp;b)const &#123; return x==b.x?id&lt;b.id:x&lt;b.x; &#125;&#125;q[maxn],tmp[maxn];int n,c,ans[maxn];int bit[maxn];void update(int now,int val)&#123; for(;now&lt;=c;now+=now&amp;-now)bit[now]+=val;&#125;int query(int now)&#123; int ans=0; for(;now&gt;=1;now-=now&amp;-now)ans+=bit[now]; return ans;&#125;void CDQ(int L,int R)&#123; if(L&gt;=R)return; int mid=L+R&gt;&gt;1; CDQ(L,mid),CDQ(mid+1,R); int l=L,r=mid+1,len=0; while(l&lt;=mid&amp;&amp;r&lt;=R) &#123; if(q[l]&lt;q[r]) &#123; if(q[l].id==0)update(q[l].y,1); tmp[++len]=q[l++]; &#125; else &#123; if(q[r].id==1)ans[q[r].pos]+=query(q[r].y); tmp[++len]=q[r++]; &#125; &#125; while(l&lt;=mid) &#123; if(q[l].id==0)update(q[l].y,1); tmp[++len]=q[l++]; &#125; while(r&lt;=R) &#123; if(q[r].id==1)ans[q[r].pos]+=query(q[r].y); tmp[++len]=q[r++]; &#125; for(int i=L;i&lt;=mid;i++) if(q[i].id==0)update(q[i].y,-1); for(int i=1;i&lt;=len;i++)q[i+L-1]=tmp[i];&#125;int top=0;bool cmp(const Query &amp;x,const Query &amp;y)&#123; return x.z==y.z?x.id&lt;y.id:x.z&lt;y.z;&#125;int cnt[maxn];int main()&#123; scanf("%d%d",&amp;n,&amp;c); for(int i=1;i&lt;=n;i++) &#123; int x,y,z; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); top++; q[top].x=x,q[top].y=y,q[top].z=z; q[top].pos=i; q[top].id=0; top++; q[top].x=x,q[top].y=y,q[top].z=z; q[top].pos=i; q[top].id=1; &#125; sort(q+1,q+1+top,cmp); CDQ(1,top); for(int i=1;i&lt;=n;i++)cnt[ans[i]]++; for(int i=1;i&lt;=n;i++)printf("%d\n",cnt[i]); //system("pause");&#125; 四位偏序例题(CDQ分治套CDQ分治套树状数组) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=4e5+10;const int maxl=5e4+10;struct node&#123; int x,y,z,id,s; node(int X=0,int Y=0,int Z=0,int Id=0,int S=0) &#123; x=X,y=Y,z=Z,id=Id,s=S; &#125;&#125;a[maxn],b[maxn],tmp[maxn];int ans[maxl];int totc=0;int tree[maxn];void add(int rt,int x)&#123;for(;rt&lt;=totc;rt+=rt&amp;-rt)tree[rt]+=x;&#125;int sum(int rt)&#123;int ans=0;for(;rt&gt;=1;rt-=rt&amp;-rt)ans+=tree[rt];return ans;&#125;void CDQ2(int l,int r)&#123; if(l&gt;=r)return; int mid=l+r&gt;&gt;1; CDQ2(l,mid),CDQ2(mid+1,r); int L=l,R=mid+1,top=l-1; while(L&lt;=mid&amp;&amp;R&lt;=r) &#123; if(b[L].y&lt;=b[R].y) &#123; if(b[L].s==0)add(b[L].z,1); tmp[++top]=b[L++]; &#125; else &#123; if(b[R].s!=0)ans[b[R].id]+=sum(b[R].z)*b[R].s; tmp[++top]=b[R++]; &#125; &#125; while(L&lt;=mid) &#123; if(b[L].s==0)add(b[L].z,1); tmp[++top]=b[L++]; &#125; while(R&lt;=r) &#123; if(b[R].s!=0)ans[b[R].id]+=sum(b[R].z)*b[R].s; tmp[++top]=b[R++]; &#125; //memset(tree,0,sizeof(tree)); for(int i=l;i&lt;=mid;i++)if(b[i].s==0)add(b[i].z,-1); for(int i=l;i&lt;=r;i++)b[i]=tmp[i];&#125;void CDQ(int l,int r)&#123; if(l&gt;=r)return; int mid=l+r&gt;&gt;1; CDQ(l,mid),CDQ(mid+1,r); int L=l,R=mid+1,top=l-1,cc=0; while(L&lt;=mid&amp;&amp;R&lt;=r) &#123; if(a[L].x&lt;=a[R].x) &#123; tmp[++top]=a[L++]; if(a[L-1].s==0)b[++cc]=a[L-1]; &#125; else &#123; tmp[++top]=a[R++]; if(a[R-1].s!=0)b[++cc]=a[R-1]; &#125; &#125; while(L&lt;=mid) &#123; tmp[++top]=a[L++]; if(a[L-1].s==0)b[++cc]=a[L-1]; &#125; while(R&lt;=r) &#123; tmp[++top]=a[R++]; if(a[R-1].s!=0)b[++cc]=a[R-1]; &#125; // cout&lt;&lt;cc&lt;&lt;endl; for(int i=l;i&lt;=r;i++)a[i]=tmp[i]; CDQ2(1,cc); &#125;int nums[400050];bool is_q[maxl];int T,q;int main()&#123; scanf("%d",&amp;T); while(T--) &#123; memset(ans,0,sizeof(ans)); scanf("%d",&amp;q); int tot=0; totc=0; for(int i=1;i&lt;=q;++i) &#123; int op,x,y,z; scanf("%d%d%d%d",&amp;op,&amp;x,&amp;y,&amp;z); if(op==1) &#123; is_q[i]=0; a[++tot]=node(x,y,z,0,0); nums[++totc]=z; &#125; else &#123; is_q[i]=1; int xx,yy,zz; scanf("%d%d%d",&amp;xx,&amp;yy,&amp;zz); nums[++totc]=zz; nums[++totc]=z; nums[++totc]=z-1; a[++tot]=node(xx,yy,zz,i,1); a[++tot]=node(xx,yy,z-1,i,-1); a[++tot]=node(xx,y-1,zz,i,-1); a[++tot]=node(x-1,yy,zz,i,-1); a[++tot]=node(x-1,y-1,zz,i,1); a[++tot]=node(x-1,yy,z-1,i,1); a[++tot]=node(xx,y-1,z-1,i,1); a[++tot]=node(x-1,y-1,z-1,i,-1); &#125; &#125; sort(nums+1,nums+1+totc); totc=unique(nums+1,nums+1+totc)-nums-1; for(int i=1;i&lt;=tot;++i)a[i].z=lower_bound(nums+1,nums+1+totc,a[i].z)-nums; CDQ(1,tot); for(int i=1;i&lt;=q;++i)if(is_q[i])printf("%d\n",ans[i]); &#125; //system("pause");&#125; CDQ分治维护斜率优化 显然某些DP方程可以进行斜率优化，但是不满足单调性，我们就要使用CDQ分治来使其满足斜率单调。 比如 $c_i&lt;\cfrac{a_j-a_k}{b_k-b_j}$ (若满足则表示 $j$ 比 $k$ 更优，$j&lt;k$ )某些题无法确定 b 的单调性，我们就需要使用CDQ分治来确定。 首先按照 c 排序，然后右边需要按照 b 排序 在对左边部分一依次插入凸包。 显然若为小于号队首元素最小，若为大于号队首元素最大。 凸包构建完成后，每次若 $c_i≥\cfrac{a_j-a_k}{b_k-b_j}$ 就弹出队首，然后根据队首更新最优答案即可。 例题： 适者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=3e5+10;struct shit&#123; long long a,d,c,ans;&#125;seq[maxn];int n,ATK;long long sumd[maxn];bool cmp1(const shit &amp;x,const shit &amp;y)&#123; return x.d*y.a&lt;x.a*y.d;&#125;bool cmp2(const shit &amp;x,const shit &amp;y)&#123; return x.a&lt;y.a;&#125;bool cmp3(const shit &amp;x,const shit &amp;y)&#123; return x.d&lt;y.d;&#125;long long calc(int pos1,int pos2)&#123; // cout&lt;&lt;seq[pos1].c&lt;&lt;' '&lt;&lt;seq[pos2].c&lt;&lt;' '&lt;&lt;seq[pos2].a&lt;&lt;' '&lt;&lt;seq[pos1].d&lt;&lt;endl; return seq[pos1].c+seq[pos2].c+seq[pos1].d*seq[pos2].a;&#125;int que[maxn];void CDQ(int l,int r)&#123; if(l==r)return; int mid=l+r&gt;&gt;1; CDQ(l,mid),CDQ(mid+1,r); sort(seq+mid+1,seq+1+r,cmp3); //for(int i=mid+1;i&lt;=r;i++)cout&lt;&lt;seq[i].d&lt;&lt;endl; int head=1,tail=1; que[1]=l; for(int i=l+1;i&lt;=mid;i++) &#123; while(head&lt;=tail&amp;&amp;seq[i].c&gt;seq[que[tail]].c)tail--; que[++tail]=i; &#125; for(int i=mid+1;i&lt;=r;i++) &#123; while(head&lt;tail&amp;&amp;calc(que[head],i)&lt;calc(que[head+1],i))head++; //cout&lt;&lt;que[head]&lt;&lt;endl; seq[i].ans=max(seq[i].ans,calc(que[head],i)); &#125; sort(seq+l,seq+1+r,cmp2);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;ATK); for(int i=1;i&lt;=n;i++) &#123; int now1,now2; scanf("%d%d",&amp;now1,&amp;now2); seq[i].a=now1; seq[i].d=(now2+ATK-1)/ATK; seq[i].ans=-1LL&lt;&lt;60; &#125; sort(seq+1,seq+1+n,cmp1); for(int i=1;i&lt;=n;i++)sumd[i]=sumd[i-1]+seq[i].d; long long cur=0,sum=0; for(int i=n;i&gt;=1;i--) &#123; seq[i].c=seq[i].d*cur+seq[i].a*(sumd[i]-1); // cout&lt;&lt;seq[i].c&lt;&lt;endl; // cout&lt;&lt;seq[i].a&lt;&lt;' '&lt;&lt;sumd[i]&lt;&lt;endl; sum+=seq[i].d*cur+seq[i].a*(seq[i].d-1); cur+=seq[i].a; &#125; for(int i=1;i&lt;=n;i++)seq[i].d=-seq[i].d; //sort(seq+1,seq+1+n,cmp2); CDQ(1,n); long long ret=1LL&lt;&lt;60; //for(int i=1;i&lt;=n;i++)cout&lt;&lt;seq[i].a&lt;&lt;' '&lt;&lt;seq[i].d&lt;&lt;endl; for(int i=1;i&lt;=n;i++)ret=min(ret,sum-seq[i].ans); printf("%lld\n",ret); //system("pause");&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gorgeous_Sequence]]></title>
    <url>%2Fpost%2FGorgeous-Sequence%2F</url>
    <content type="text"><![CDATA[1、当 $ma≤x$ 时这个修改不会对这个节点产生影响，直接退出。 2、$当 se&lt;x&lt;ma$ 时显然这一次修改只会影响所有的最大值，所以我们把 $sum$ 加上 $t∗(x-ma)$，$ma$ 更新为 x ，接着打上标记 $cm$ 表示这个区间的最大值变成了 $cm$，退出。 3、当 $x≤se$ 时我们无法直接更新这个节点的信息，一次我们直接对它的左右儿子递归搜索。 可以证明复杂度为 $O(m \log⁡n)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;long long mx[maxn&lt;&lt;2],se[maxn&lt;&lt;2],t[maxn&lt;&lt;2],sum[maxn&lt;&lt;2];void add(int rt,long long v)&#123; sum[rt]+=t[rt]*(v-mx[rt]); mx[rt]=v;&#125;void pushup(int rt)&#123; t[rt]=0; sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1]; mx[rt]=max(mx[rt&lt;&lt;1],mx[rt&lt;&lt;1|1]); se[rt]=max(se[rt&lt;&lt;1],se[rt&lt;&lt;1|1]); if(mx[rt&lt;&lt;1]!=mx[rt&lt;&lt;1|1])se[rt]=max(se[rt],min(mx[rt&lt;&lt;1],mx[rt&lt;&lt;1|1])); if(mx[rt&lt;&lt;1]==mx[rt])t[rt]+=t[rt&lt;&lt;1]; if(mx[rt&lt;&lt;1|1]==mx[rt])t[rt]+=t[rt&lt;&lt;1|1];&#125;void pushdown(int rt)&#123; if(mx[rt]&lt;mx[rt&lt;&lt;1])add(rt&lt;&lt;1,mx[rt]); if(mx[rt]&lt;mx[rt&lt;&lt;1|1])add(rt&lt;&lt;1|1,mx[rt]);&#125;void update(int l,int r,int L,int R,int rt,long long v)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; if(mx[rt]&lt;=v)return; if(se[rt]&lt;v) &#123; add(rt,v); return; &#125; &#125; int mid=l+r&gt;&gt;1; pushdown(rt); if(L&lt;=mid)update(l,mid,L,R,rt&lt;&lt;1,v); if(R&gt;mid)update(mid+1,r,L,R,rt&lt;&lt;1|1,v); pushup(rt);&#125;long long querys(int l,int r,int L,int R,int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)return sum[rt]; int mid=l+r&gt;&gt;1; long long ans=0; pushdown(rt); if(L&lt;=mid)ans+=querys(l,mid,L,R,rt&lt;&lt;1); if(R&gt;mid)ans+=querys(mid+1,r,L,R,rt&lt;&lt;1|1); return ans;&#125;long long querym(int l,int r,int L,int R,int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)return mx[rt]; int mid=l+r&gt;&gt;1; long long ans=0; pushdown(rt); if(L&lt;=mid)ans=max(ans,querym(l,mid,L,R,rt&lt;&lt;1)); if(R&gt;mid)ans=max(ans,querym(mid+1,r,L,R,rt&lt;&lt;1|1)); return ans;&#125;int a[maxn],n,m;void build(int l,int r,int rt)&#123; if(l==r) &#123; mx[rt]=a[l],t[rt]=1,sum[rt]=a[l],se[rt]=-1; return ; &#125; int mid=l+r&gt;&gt;1; build(l,mid,rt&lt;&lt;1),build(mid+1,r,rt&lt;&lt;1|1); pushup(rt); return ;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); build(1,n,1); while(m--) &#123; int op,x,y,z; scanf("%d%d%d",&amp;op,&amp;x,&amp;y); //cout&lt;&lt;op&lt;&lt;' '&lt;&lt;x&lt;&lt;' '&lt;&lt;y&lt;&lt;endl; if(op==1)printf("%lld\n",querym(1,n,x,y,1)); if(op==2)printf("%lld\n",querys(1,n,x,y,1)); if(op==0)scanf("%d",&amp;z),update(1,n,x,y,1,z); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Global Round 3比赛小结]]></title>
    <url>%2Fpost%2FCodeforces-Global-Round-3%E6%AF%94%E8%B5%9B%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这次比赛失误比较严重，主要问题出在了T3和T2上。 刚开始的时候没有考虑到许多细节导致我查了很久的错，最后想出了T4却没有写完。 英文题有点坑爹，很容易就没有看到隐藏在题目中的一些细节。 需要增强：代码能力 T1,T2,T3太水了就不说了 T4 大意就是给你一些二元组 $(a_i,b_i)$ 要求从中选出尽量多的二元组使得他们排列起来满足 $a_i\gt b_i，b_i\lt a_{i+1},a_{i+1}\gt b_{i+1}$ 或者 $a_i\lt b_i，b_i\gt a_{i+1},a_{i+1}\lt b_{i+1}$ 显然你会发现这两种情况是独立的可以单独计算。 那么每个二元组可以根据 $a_i$ 和 $b_i$ 的大小关系把它们分到第一组或者第二组 因为两种情况本质上来说是一样的。 这里就简述一下第一组的情况，首先按照 $a_i$ 排序，然后就是要统计对于每个二元组，它能够排在前面那些二元组的后面即 $b_j&gt;a_i$ ，那么到第 $i$ 个位置能选出的最多的二元组记为 $dp_i$，相当于是找到前面 $b_j&gt;a_i$ 中 $dp_j$ 最大值，线段树维护就好了，然后输出方案的话就记录一下最大值的位置。 对于第二组我们可以交换 $a_i，b_i$ 就和第一种情况一样了。]]></content>
      <categories>
        <category>比赛总结</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2008」球形空间产生器]]></title>
    <url>%2Fpost%2F%E3%80%8CJSOI2008%E3%80%8D%E7%90%83%E5%BD%A2%E7%A9%BA%E9%97%B4%E4%BA%A7%E7%94%9F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[对于每一个点我们都可以列出这样的方程 \sum_{j=1}^n(x_j-a_{ij})^2=R上下差为 \sum_{j=1}^n(x_j-a_{ij})^2-(x_j-a_{i+1j})^2=0 \sum_{j=1}^na_{ij}^2-a_{i+1j}^2-2a_{ij}x_j+2a_{i+1j}x_j=0所以每一项的系数为 $-x_j(2a_{ij}-2a_{i+1j})$ 常数项为 $\sum_{j=1}^n-a_{ij}^2+a_{i+1j}^2$ 共 $n$ 个未知数，$n$ 个方程高斯消元即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=10+5;double a[maxn][maxn];double p[maxn][maxn];int n;void gauss()&#123; for(int i=1;i&lt;=n;i++) &#123; int now=i; for(int j=i+1;j&lt;=n;j++)if(fabs(a[j][i])&gt;fabs(a[now][i]))now=j; if(now!=i)for(int j=i;j&lt;=n+1;j++)swap(a[now][j],a[i][j]); for(int k=i+1;k&lt;=n+1;k++) &#123; double t=a[k][i]/a[i][i]; for(int j=i;j&lt;=n+1;j++)a[k][j]-=a[i][j]*t; &#125; &#125; for(int i=n;i&gt;=1;i--) &#123; for(int j=i+1;j&lt;=n;j++) a[i][n+1]-=a[j][n+1]*a[i][j]; a[i][n+1]/=a[i][i]; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n+1;i++) for(int j=1;j&lt;=n;j++)scanf("%lf",&amp;p[i][j]); for(int i=1;i&lt;=n;i++) &#123; double tot=0; for(int j=1;j&lt;=n;j++) &#123; a[i][j]+=2*p[i][j]-2*p[i+1][j]; tot+=p[i][j]*p[i][j]-p[i+1][j]*p[i+1][j]; &#125; a[i][n+1]=tot; &#125; gauss(); for(int i=1;i&lt;=n;i++)printf("%.3lf ",a[i][n+1]); return 0; &#125;]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2016」游戏]]></title>
    <url>%2Fpost%2F%E3%80%8CSDOI2016%E3%80%8D%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[每次在路径上加的数是个一次函数，容易看出是树剖+李超线段树维护函数最小值。 我们需要构造一个坐标系然后就可以直接套李超线段树，不难发现我们可以把每个点的深度作为它的横坐标，那么一条重链上的点的横坐标都是连续的。 那么对于 $u\to LCA(u,v)$上的每个点 $i$ 纵坐标就是 $y=k(dis_u -dis_i)+b$ 所以我们相当于给$u\to LCA(u,v)$ 加上了一个 $y=kx+b$ 的直线 $k=-a$ ，$b=a\dot{} dis_u+b$ 那么对于 $v\to LCA(u,v)$上的每个点 $i$ 纵坐标就是 $y=k(dis_u+dis_i-2dis_{lca(u,v)})+b$ 同理相当于给$v\to LCA(u,v)$ 加上了一个 $y=kx+b$ 的直线 $k=a$ ，$b=a\dot{} (dis_u-2dis_{lca(u,v)})+b$ 直接维护就好了，要注意开始的时候每个点有一条 $k=0,b=inf$ 的直线，被这个坑了很久。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;const long long inf=123456789123456789LL;struct Seg&#123;long long k,b;&#125;;struct edge&#123;int v,nxt,w;&#125;e[maxn&lt;&lt;1];int top[maxn],siz[maxn],son[maxn],head[maxn],ecnt=0,fa[maxn],dfn[maxn],dep[maxn],idx=0;long long dis[maxn];int n,m;long long val[maxn];void add(int u,int v,int w)&#123; e[++ecnt]=(edge)&#123;v,head[u],w&#125;,head[u]=ecnt; e[++ecnt]=(edge)&#123;u,head[v],w&#125;,head[v]=ecnt;&#125;void dfs1(int u,int pre)&#123; siz[u]=1; dep[u]=dep[pre]+1,fa[u]=pre; for(int i=head[u];~i;i=e[i].nxt) &#123; int v=e[i].v; if(v==pre)continue; dis[v]=dis[u]+e[i].w; dfs1(v,u); siz[u]+=siz[v]; if(siz[son[u]]&lt;siz[v])son[u]=v; &#125;&#125;void dfs2(int u,int up)&#123; top[u]=up; dfn[u]=++idx; val[idx]=dis[u]; if(!son[u])return; dfs2(son[u],up); for(int i=head[u];~i;i=e[i].nxt) &#123; int v=e[i].v; if(v==fa[u]||v==son[u])continue; dfs2(v,v); &#125;&#125;Seg s[maxn&lt;&lt;2];//int hav[maxn&lt;&lt;2];long long minn[maxn&lt;&lt;2];void pushdown(int rt,int l,int r,Seg now)&#123;// if(!hav[rt])&#123;s[rt]=now;hav[rt]=1;return;&#125;巨大坑点 long long l1=now.k*val[l]+now.b,r1=now.k*val[r]+now.b; long long l2=s[rt].k*val[l]+s[rt].b,r2=s[rt].k*val[r]+s[rt].b; minn[rt]=min(minn[rt],min(l1,r1)); if(l1&gt;=l2&amp;&amp;r1&gt;=r2)return; if(l1&lt;=l2&amp;&amp;r1&lt;=r2)&#123;s[rt]=now;return;&#125; int mid=l+r&gt;&gt;1;double pos=(now.b-s[rt].b)/(s[rt].k-now.k); if(pos&lt;=val[mid])pushdown(rt&lt;&lt;1,l,mid,l1&lt;l2?now:s[rt]); else pushdown(rt&lt;&lt;1|1,mid+1,r,r1&lt;r2?now:s[rt]); if((l1&lt;l2&amp;&amp;pos&gt;=val[mid])||(r1&lt;r2&amp;&amp;pos&lt;val[mid]))s[rt]=now; minn[rt]=min(minn[rt],min(minn[rt&lt;&lt;1],minn[rt&lt;&lt;1|1]));&#125;void update(int rt,int l,int r,int L,int R,Seg now)&#123; //cout&lt;&lt;L&lt;&lt;' '&lt;&lt;R&lt;&lt;' '&lt;&lt;now.k&lt;&lt;' '&lt;&lt;now.b&lt;&lt;endl; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;pushdown(rt,l,r,now);return;&#125; int mid=l+r&gt;&gt;1; if(L&lt;=mid)update(rt&lt;&lt;1,l,mid,L,R,now); if(R&gt;mid)update(rt&lt;&lt;1|1,mid+1,r,L,R,now); minn[rt]=min(minn[rt],min(minn[rt&lt;&lt;1],minn[rt&lt;&lt;1|1]));&#125;void build(int rt,int l,int r)&#123; minn[rt]=inf; s[rt].b=inf; if(l==r)return; int mid=l+r&gt;&gt;1; build(rt&lt;&lt;1,l,mid),build(rt&lt;&lt;1|1,mid+1,r);&#125;long long query(int rt,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)return minn[rt]; long long ret=inf; if(s[rt].b!=inf) &#123; int ll=max(l,L),rr=min(r,R); ret=min(s[rt].k*val[ll],s[rt].k*val[rr])+s[rt].b; &#125; int mid=l+r&gt;&gt;1; if(L&lt;=mid)ret=min(ret,query(rt&lt;&lt;1,l,mid,L,R)); if(R&gt;mid)ret=min(ret,query(rt&lt;&lt;1|1,mid+1,r,L,R)); return ret;&#125;int lca(int u,int v)&#123; while(top[u]!=top[v]) &#123; if(dep[top[u]]&lt;dep[top[v]])swap(u,v); u=fa[top[u]]; &#125; return dep[u]&lt;dep[v]?u:v;&#125;void add(int u,int v,Seg t)&#123; while(top[u]!=top[v])update(1,1,n,dfn[top[u]],dfn[u],t),u=fa[top[u]]; update(1,1,n,dfn[v],dfn[u],t);&#125;long long ask(int u,int v)&#123; long long ans=inf; while(top[u]!=top[v]) &#123; if(dep[top[u]]&lt;dep[top[v]])swap(u,v); ans=min(ans,query(1,1,n,dfn[top[u]],dfn[u])); u=fa[top[u]]; &#125; if(dep[u]&gt;dep[v])swap(u,v); return min(ans,query(1,1,n,dfn[u],dfn[v]));&#125;int main()&#123; memset(head,-1,sizeof(head)); scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;n;i++) &#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add(u,v,w); &#125; dfs1(1,0); dfs2(1,1); build(1,1,n); //cout&lt;&lt;val[1]&lt;&lt;' '&lt;&lt;val[2]&lt;&lt;' '&lt;&lt;val[3]&lt;&lt;endl; while(m--) &#123; int op; scanf("%d",&amp;op); if(op==1) &#123; int u,v,a,b; scanf("%d%d%d%d",&amp;u,&amp;v,&amp;a,&amp;b); int t=lca(u,v); // cout&lt;&lt;t&lt;&lt;"haha"&lt;&lt;endl; add(u,t,(Seg)&#123;-a,a*1LL*dis[u]+b&#125;); add(v,t,(Seg)&#123;a,a*1LL*(dis[u]-dis[t]*2)+b&#125;); &#125; else &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); printf("%lld\n",ask(u,v)); &#125; &#125;// cout&lt;&lt;val[1]&lt;&lt;' '&lt;&lt;val[2]&lt;&lt;' '&lt;&lt;val[3]&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「学习笔记」李超线段树]]></title>
    <url>%2Fpost%2F%E3%80%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8D%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[「Heoi2013」 Segment有一个二维平面，你需要支持两种操作，插入一条线段，查询一条直线 $x=k$ 与其相交的最上面的一条线段。在学习之前离线做法可以用 $cdq$ 搞定，在线的话用平衡树也可以实现，李超树的做法相较于这两种要巧妙一些，核心的思想在于标记永久化维护覆盖区间中点的最高的线段。 考虑当前有一个线段树上的区间，要在这个区间里插入一条线段并维护答案，不妨分以下几类讨论： 如果当前这个区间还没有线段或者新加入的线段完全覆盖原来的线段，那么新加入的线段一定替换原来的线段 如果当前新加入的线段被原来的线段完全覆盖，那么这条新加入的线段一定不会再有用了。 将新加入的线段和原来的线段求交，将交所在的那半边较劣的线段下放到对应的儿子，更新区间中点的最高的线段。 此时维护的相当于是标记永久化的若干个线段，求答案就是将 $k$ 对应路径上的标记取最优线段，复杂度瓶颈所在的第三种情况每次都只会走一个儿子下放，所以从插入一条线段的复杂度是 $O(logn) $，由于要区间修改要在 $logn$ 个节点上插入线段，所以总复杂度 $O(nlogn)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e4+10;const double eps=1e-8;struct segment&#123;double k,b;int id;&#125;;segment s[maxn&lt;&lt;2];int hav[maxn&lt;&lt;2];void pushdown(int rt,int l,int r,segment now)&#123; if(!hav[rt])&#123;s[rt]=now;hav[rt]=1;return;&#125; double l1=now.k*l+now.b,r1=now.k*r+now.b; double l2=s[rt].k*l+s[rt].b,r2=s[rt].k*r+s[rt].b; if(l1&lt;=l2&amp;&amp;r1&lt;=r2)return ; if(l1&gt;=l2&amp;&amp;r1&gt;=r2)&#123;s[rt]=now;return;&#125; int mid=l+r&gt;&gt;1;double pos=(now.b-s[rt].b)/(s[rt].k-now.k); if(pos&lt;=mid)pushdown(rt&lt;&lt;1,l,mid,r1&gt;r2?s[rt]:now); else pushdown(rt&lt;&lt;1|1,mid+1,r,l1&gt;l2?s[rt]:now); if((l1&gt;l2&amp;&amp;pos&gt;=mid)||(r1&gt;r2&amp;&amp;pos&lt;mid))s[rt]=now;&#125;void update(int rt,int l,int r,int L,int R,segment now)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;pushdown(rt,l,r,now);return;&#125; int mid=l+r&gt;&gt;1; if(L&lt;=mid)update(rt&lt;&lt;1,l,mid,L,R,now); if(R&gt;mid)update(rt&lt;&lt;1|1,mid+1,r,L,R,now);&#125;segment query(int rt,int l,int r,int pos)&#123; if(l==r)return hav[rt]?s[rt]:(segment)&#123;0,0,0&#125;; int mid=l+r&gt;&gt;1;segment now; if(pos&lt;=mid)now=query(rt&lt;&lt;1,l,mid,pos); else now=query(rt&lt;&lt;1|1,mid+1,r,pos); if(!hav[rt])return now; double y1=pos*now.k+now.b,y2=s[rt].k*pos+s[rt].b; if(!now.id||(y1&lt;y2)||(fabs(y1-y2)&lt;eps&amp;&amp;s[rt].id&lt;now.id))now=s[rt]; return now;&#125;int n;int lim=39989;int lastans=0,tot=0;int main()&#123; scanf("%d",&amp;n); while(n--) &#123; int op; scanf("%d",&amp;op); if(op==0) &#123; int pos;scanf("%d",&amp;pos); pos=(pos+lastans-1)%lim+1; segment ans=query(1,1,lim,pos); printf("%d\n",lastans=ans.id); &#125; else &#123; int X0,X1,Y0,Y1; scanf("%d%d%d%d",&amp;X0,&amp;Y0,&amp;X1,&amp;Y1); X0=(X0+lastans-1)%lim+1,X1=(X1+lastans-1)%lim+1; Y0=(Y0+lastans-1)%(int)(1e9)+1,Y1=(Y1+lastans-1)%(int)(1e9)+1; if(X0&gt;X1)swap(X0,X1),swap(Y0,Y1); if(X0==X1)&#123;update(1,1,lim,X0,X1,(segment)&#123;0.0,1.0*max(Y0,Y1),++tot&#125;);continue;&#125; double k=1.0*(Y1-Y0)/(X1-X0),b=1.0*Y1-k*X1; update(1,1,lim,X0,X1,(segment)&#123;k,b,++tot&#125;); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点分治/动态点分治]]></title>
    <url>%2Fpost%2F%E7%82%B9%E5%88%86%E6%B2%BB-%E5%8A%A8%E6%80%81%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[链接: https://pan.baidu.com/s/1l1tWtvPfVAIxxu2hK1WTBQ 提取码: m42i BZOJ震波代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=3e5+10;const int maxl=1e7+10;struct edge&#123; int v,next;&#125;e[maxn];int head[maxn],cnt=0,idx=0;int val[maxn];int dfn[maxn],dep[maxn];int up[maxn][18];int log2[maxn];int mxsize[maxn],nodecnt,root;int size[maxn];int fa[maxn];int n,m;void add(int u,int v)&#123; e[++cnt]=(edge)&#123;v,head[u]&#125;; head[u]=cnt; e[++cnt]=(edge)&#123;u,head[v]&#125;; head[v]=cnt;&#125;void dfs(int u,int pre)&#123; dfn[u]=++idx; up[idx][0]=dep[u]; for(int i=head[u];~i;i=e[i].next) &#123; int v=e[i].v; if(v==pre)continue; dep[v]=dep[u]+1; dfs(v,u); up[++idx][0]=dep[u]; &#125;&#125;int dis(int u,int v)&#123; int ans=dep[u]+dep[v]; u=dfn[u],v=dfn[v]; if(u&gt;v)swap(u,v); int len=log2[v-u+1]; return ans-min(up[u][len],up[v-(1&lt;&lt;len)+1][len])*2;&#125;int sum[maxl],son[maxl][2];int num=0;int vis[maxn];int roota[maxn];int rootb[maxn];void update(int &amp;rt,int l,int r,int pos,int v)&#123; if(!rt)rt=++num; sum[rt]+=v; if(l==r)return; int mid=l+r&gt;&gt;1; if(pos&lt;=mid)update(son[rt][0],l,mid,pos,v); else update(son[rt][1],mid+1,r,pos,v);&#125;int query(int rt,int l,int r,int pos)&#123; if(!rt)return 0; if(l==r)return sum[rt]; int mid=l+r&gt;&gt;1; if(pos&lt;=mid)return query(son[rt][0],l,mid,pos); return query(son[rt][1],mid+1,r,pos)+sum[son[rt][0]];&#125;void getroot(int u,int pre)&#123; size[u]=1; mxsize[u]=0; for(int i=head[u];~i;i=e[i].next) &#123; int v=e[i].v; if(v==pre||vis[v])continue; getroot(v,u); size[u]+=size[v]; mxsize[u]=max(mxsize[u],size[v]); &#125; if(nodecnt-size[u]&gt;mxsize[u])mxsize[u]=n-size[u]; if(mxsize[u]&lt;mxsize[0])mxsize[0]=mxsize[u],root=u;&#125;void init_tree(int to,int pre,int u)&#123; //cout&lt;&lt;dis(2,2)&lt;&lt;endl; update(roota[to],0,n-1,dis(u,to),val[u]); if(fa[to])update(rootb[to],0,n-1,dis(u,fa[to]),val[u]); for(int i=head[u];~i;i=e[i].next) &#123; int v=e[i].v; if(vis[v]||pre==v)continue; init_tree(to,u,v); &#125;&#125;void Divide(int u)&#123; vis[u]=1; init_tree(u,0,u); for(int i=head[u];~i;i=e[i].next) &#123; int v=e[i].v; if(vis[v])continue; nodecnt=size[v],mxsize[0]=0x3f3f3f3f,root=0; getroot(v,u); fa[root]=u; Divide(root); &#125;&#125;void Update(int u,int v)&#123; for(int i=u;i;i=fa[i]) &#123; update(roota[i],0,n-1,dis(i,u),v-val[u]); if(fa[i])update(rootb[i],0,n-1,dis(u,fa[i]),v-val[u]); &#125; val[u]=v;&#125;int Query(int u,int v)&#123; int ans=0; for(int i=u;i;i=fa[i]) &#123; if(v&gt;=dis(i,u))ans+=query(roota[i],0,n-1,v-dis(i,u)); if(v&gt;=dis(u,fa[i])&amp;&amp;fa[i])ans-=query(rootb[i],0,n-1,v-dis(u,fa[i])); &#125; return ans;&#125;int u,v;int main()&#123;// freopen("1.in","r",stdin); memset(head,-1,sizeof(head)); scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;val[i]); for(int i=1;i&lt;n;i++)scanf("%d%d",&amp;u,&amp;v),add(u,v); for(int i=2;i&lt;=2*n;i++)log2[i]=log2[i&gt;&gt;1]+1; dfs(1,0); for(int i=1;(1&lt;&lt;i)&lt;=idx;i++) for(int j=1;j&lt;=idx-(1&lt;&lt;i)+1;j++) up[j][i]=min(up[j][i-1],up[j+(1&lt;&lt;(i-1))][i-1]); mxsize[0]=0x3f3f3f3f,nodecnt=n,root=0; getroot(1,0),Divide(root); int last=0; while(m--) &#123; int op,x,y; scanf("%d%d%d",&amp;op,&amp;x,&amp;y),x^=last,y^=last; if(!op)printf("%d\n",last=Query(x,y)); else Update(x,y); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯反演]]></title>
    <url>%2Fpost%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[定义①当 $d=1$ 时，$\mu(d)=1$； ②当 $d=Π^{k}_{i=1}p_i$ 且 $pi$ 为互异素数时，$\mu(d)=(−1)^k$。(说直白点，就是d分解质因数后，没有幂次大于平方的质因子，此时函数值根据分解的个数决定) ③只要当 $d$ 含有任何质因子的幂次大于2，则函数值为0. 性质①设F(n)=\sum_{d|n}{f(d)}则 f(n)=\sum_{d|n}{F(\cfrac{n}{d})}\times\mu(d)②\sum_{d|n}\cfrac{μ(d)}{d}=\frac{ϕ(n)}{n}③\sum_{d|n}\mu(d)=[n=1] 莫比乌斯函数求法:123456789101112131415void init()&#123; not_prime[1]=1; mu[1]=1; for(int i=2;i&lt;=maxn-10;i++) &#123; if(!not_prime[i])prime[++cnt]=i,mu[i]=-1; for(int j=1;j&lt;=cnt&amp;&amp;prime[j]*i&lt;=maxn-10;j++) &#123; not_prime[prime[j]*i]=1; if(i%prime[j]==0)break; mu[prime[j]*i]=-mu[i]; &#125; &#125;&#125; 例题：1：将 $a_i$ 改为 $b$ 。2：给定一个数 $i$ ，求所有 $gcd(i,j)=1$ 时的 $a_j$ 的总和。 题解:设 ans=\sum_{j=1}^{n}a[j]\times[gcd(i,j)==1]根据莫比乌斯反演函数的性质 ans=\sum_{j=1}^{n}a[j]\times\sum_{d|gcd(i,j)}\mu(d)得 ans=\sum_{d=1}^{n}\mu(d)\times\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}a[j\times d]设 sum[i]=\sum_{j=1}^{\lfloor\frac{n}{i}\rfloor}a[j\times i]则 ans=\sum_{d=1}^{n}\mu(d)\times sum[d]所以我们只需要通过数论分块维护 $sum[i]​$ 就好了时间复杂度 $O(n\sqrt{n})​$]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Treap]]></title>
    <url>%2Fpost%2FTreap%2F</url>
    <content type="text"><![CDATA[TreapTreap=Heap+Tree 树堆，在数据结构中也称Treap，是指有一个随机附加域满足堆的性质的二叉搜索树，其结构相当于以随机数据插入的二叉搜索树。其基本操作的期望时间复杂度为$O(log_2n)$。相对于其他的平衡二叉搜索树，Treap的特点是实现简单，且能基本实现随机平衡的结构，Treap的本质其实就是笛卡尔树。 Treap 维护堆的性质的方法只用到了左旋和右旋， 编程复杂度比Splay小一点， 并且在两者可完成的操作速度有明显优势 c++中自带的 $rand()$ 函数，可能因为常数较大产生效率瓶颈所以我们手写随机数生成器。 12345inline int rand()&#123; static int seed=9787302; return seed=((seed^1002124)*3344532+23482981)%10000007;&#125; Treap维护性质用到了左旋以及右旋，为了方便起见我们将左旋右旋写成一个函数。 其中 $d$ 为 $0$ 表示将右旋（把左儿子旋转上来），为 $1$ 表示左旋（把右儿子旋转上来）。 1234567inline void rotate(int &amp;rt,int d)&#123; int tmp=son[rt][d]; son[rt][d]=son[tmp][d^1]; son[tmp][d^1]=rt; pushup(rt),pushup(rt=tmp);&#125; 插入操作其实与其他平衡树大同小异，但是如果说这个结点不满足了堆的性质，我们需要通过旋转调整。 12345678910111213141516void insert(int &amp;rt,int val)&#123; if(!rt) &#123; key[rt=++nodecnt]=val; siz[rt]=cnt[rt]=1; son[rt][0]=son[rt][1]=0; rnk[rt]=rand(); return ; &#125; siz[rt]++; if(key[rt]==val)&#123;cnt[rt]++;return;&#125; int d=key[rt]&lt;val; insert(son[rt][d],val); if(rnk[rt]&gt;rnk[son[rt][d]])rotate(rt,d);&#125; 删除操作，我们只需要将需要删除的结点一路旋转到根节点就行了 123456789101112void delet(int &amp;rt,int val) &#123; if(!rt)return; if(key[rt]==val) &#123; if(cnt[rt]&gt;1)&#123;siz[rt]--,cnt[rt]--;return;&#125; int d=rnk[son[rt][0]]&gt;rnk[son[rt][1]]; if(son[rt][0]==0||son[rt][1]==0)rt=son[rt][0]+son[rt][1]; else rotate(rt,d),delet(rt,val); &#125; else siz[rt]--,delet(son[rt][key[rt]&lt;val],val); &#125; 下面就是一些平衡树的基本操作 需要注意的是，Treap并不能够随便改变树的机构，所以操作时，不会用到旋转操作。 所以一般的Treap并不支持序列操作。 12345678910111213141516171819202122232425262728int getrank(int rt,int val)&#123; if(!rt)return 0; if(key[rt]==val)return siz[son[rt][0]]; if(key[rt]&gt;val)return getrank(son[rt][0],val); return getrank(son[rt][1],val)+siz[son[rt][0]]+cnt[rt];&#125;int findrank(int rt,int k)&#123; while(1) &#123; if(k&lt;=siz[son[rt][0]])rt=son[rt][0]; else if(k&gt;siz[son[rt][0]]+cnt[rt])k-=siz[son[rt][0]]+cnt[rt],rt=son[rt][1]; else return key[rt]; &#125;&#125;int pre(int rt,int val)&#123; if(!rt)return -0x3f3f3f3f; if(key[rt]&gt;=val)return pre(son[rt][0],val); return max(pre(son[rt][1],val),key[rt]);&#125;int suc(int rt,int val)&#123; if(!rt)return 0x3f3f3f3f; if(key[rt]&lt;=val)return suc(son[rt][1],val); return min(suc(son[rt][0],val),key[rt]);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[半平面交]]></title>
    <url>%2Fpost%2F%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[定义：半平面： 顾名思义，就是平面的一半。一条直线会把平面分成两部分，就是两个半平面。对于半平面，我们可以用直线方程式如：$ax + by &gt;= c$ 表示，更常用的是用直线表示。 半平面交： 顾名思义，就是多个半平面求交集。其结果可能是一个凸多边形、无穷平面、直线、线段、点等。 多边形的核： 如果多边形中存在一个区域使得在区域中可以看到多边形中任意位置（反之亦然），则这个区域就是多边形的核。可以用半平面交来求解。 极点： 点 $(x,y)$ 与原点的连线与 $x$ 轴的夹角，其范围为 [0,360]. 为了方便求解我们假设所有的直线的左侧为我们所需要的半平面。 一般来说求解半平面交有两种方法 ① 分治法 $O(n\log_2 n)$ ② 增量法 $O(n\log_2 n)$ 但是在这里由于分治法常数较大，代码实现较第二种复杂，所以我们着重介绍第二种方法。 算法流程① 将所有直线极角排序,角度相同的保留下需要的一个 ② 用一个双端队列存储当前半平面交,每次通过判断队首与队尾第一个交点是否满足当前直线来更新 ③ 先用队尾判定队首交点是否合法,再用队首判断队尾交点是否合法 ④ 最后求出来的半平面交是一个凸多边形 极角排序如下图排序后 $(a,b)，(c,d)，(e,f)，(g,h)，(i,j)$ 所以我们可以更方便的逆时针依次构造，半平面交 由于我们规定了所有的直线的左侧为我们所需要的半平面 所以极角相同的直线，我们保留最靠右的。 构造半平面交我们可以依照以下流程来构造一个半平面交，并且构造完成的半平面交有多种情况 ① 直线、线段、点不合法 ② 凸多边形，无穷平面（可以增加4个用于限制的半平面，使得平面变得有限） 我们维护两个双端队列 一个储存当前有用的直线（半平面），一个储存半平面交的点。 我们依次加入每一条直线（半平面），在加入之前先将之前保存了的点，但不是最终半平面交中的点弹出队列 如下图我们首先让 直线$AB$ 进入队列，再加入直线$FG$，并且求出 $AB$ 与 $FG$ 的交点 $H$，并且把它加入第二个队列里 那么加入 直线$CD$ 时我们会发现， $H$ 这个点在半平面之外，那么就将它弹出队列，同时将这条边也弹出队列。 所以只要一个点在加入的这条直线的右边我们就将它弹出。 为什么我们要使用双端队列？ 可以明显的发现，双端队列的中的点是逆时针排列的 且满足一定的单调性（这个需要自己画图思考，或者配合以下图片思考） 当前加入一条直线，存放点的队列中相邻的两个元素，所对应的直线的极角满足 $\angle a&lt;=\angle b$（$a$ 对应点的在队列中的位置位置小于 $b$） 那么也就是说，这条直线要么使队首的点处于半平面外，要么使队尾的点处于半平面外 但是因为构造半平面交是环形的构造，如下图 我们顺次处理 $IJ$ ，$AB$ ，$CD$ ，$EF$，$GH$ 所以当处理到 $GH$ 的时候会发现，$K$ 点是需要弹出的点但是，$K$ 因为在处理 $AB$ 时就已经加入了队列而且处在队列的首部，所以我们如果要弹出 $K$ 就必须要维护一个双端队列来支持我们的弹出队首的操作。 删去不合法的点最后队首和队尾都会剩下一些点，它们在半平面交之外 如下图，由于半平面交构造时实际是一个上凸壳和下凸壳，然后是环形的，所以说，会发现某些情况下，有些点多余了 我们需要用队首的直线，判断一下多余的队尾队首的点。 POJ2451模板题，求半平面交面积 AC代码，有注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const double eps=1e-6;const int maxn=2e5+10;const double Pi=acos(-1.00);inline int dcmp(double x)&#123; if(x&gt;eps)return 1; return x&lt;-eps?-1:0;&#125;struct Vector&#123; double x,y; Vector(double X=0,double Y=0) &#123; x=X,y=Y; &#125; bool operator == (const Vector &amp;b)const &#123; return dcmp(x-b.x)==0&amp;&amp;dcmp(y-b.y)==0; &#125; double angle() &#123; return atan2(y,x);//求出极角 &#125;&#125;;typedef Vector Point;Vector operator + (Vector a,Vector b)&#123;return Vector(a.x+b.x,a.y+b.y);&#125;Vector operator - (Vector a,Vector b)&#123;return Vector(a.x-b.x,a.y-b.y);&#125;Vector operator * (Vector a,double b)&#123;return Vector(a.x*b,a.y*b);&#125;Vector operator / (Vector a,double b)&#123;return Vector(a.x/b,a.y/b);&#125;struct Line&#123; Point s,t; double ang; Line(Point X=Vector(),Point Y=Vector()) &#123; s=X,t=Y,ang=(Y-X).angle(); &#125;&#125;;typedef Line Segment;double dot(Vector a,Vector b)&#123; return a.x*b.x+a.y*b.y;&#125;double cross(Vector a,Vector b)&#123; return a.x*b.y-a.y*b.x;&#125;bool is_parallel(Line a,Line b)//判断a,b直线是否平行&#123; return dcmp(cross(a.t-a.s,b.t-b.s))==0;&#125;Point intersection(Line a,Line b)//求出a,b的交点&#123; return a.s+(a.t-a.s)*(cross(b.t-b.s,a.s-b.s)/cross(a.t-a.s,b.t-b.s));&#125;double area(Point *p,int n)//求出多边形的面积&#123; double res=0; p[n+1]=p[1]; for(int i=1;i&lt;=n;i++)res+=cross(p[i],p[i+1]); return fabs(res/2);&#125;bool operator &lt; (const Line &amp;a,const Line &amp;b)//极角排序，如果极角相同则，选择最靠左的直线&#123; double r=a.ang-b.ang; if(dcmp(r)!=0)return dcmp(r)==-1; return dcmp(cross(a.t-a.s,b.t-a.s))==-1;&#125;bool OnRight(Line a,Point b)//检查b是否在a直线的右边&#123; return dcmp(cross(a.t-a.s,b-a.s))&lt;0;&#125;bool SI(Line *l,int n,Point *s,int &amp;m)//增量法求半平面交&#123; static Line que[maxn]; static Point que2[maxn];//两个双端队列 int head=0,tail=0; sort(l+1,l+1+n); que[0]=l[1]; for(int i=2;i&lt;=n;i++) if(dcmp(l[i].ang-l[i-1].ang)!=0)//极角相等的直线，取一个 &#123; if(head&lt;tail&amp;&amp;(is_parallel(que[head],que[head+1])||is_parallel(que[tail],que[tail-1])))return false;//如果两个直线共线，但是极角不同，则没有半平面交 while(head&lt;tail&amp;&amp;OnRight(l[i],que2[tail-1]))tail--;//如果在直线右边，删除点 while(head&lt;tail&amp;&amp;OnRight(l[i],que2[head]))head++; que[++tail]=l[i]; if(head&lt;tail)que2[tail-1]=intersection(que[tail],que[tail-1]);//加入新点 &#125; while(head&lt;tail&amp;&amp;OnRight(que[head],que2[tail-1]))tail--;//删去多余点 while(head&lt;tail&amp;&amp;OnRight(que[tail],que2[head]))head++; if(tail-head&lt;=1)return false;//只有一个点或零个点，没有半平面交 que2[tail]=intersection(que[head],que[tail]);//加入最后一条边，和第一条边的交点 m=0; for(int i=head;i&lt;=tail;i++)s[++m]=que2[i]; return true;&#125;const double lim=10000;int n,m;Point p[maxn];Line l[maxn];double solve()&#123; Point a=Point(0,0);//加入最大限制，防止半平面交无限大 Point b=Point(lim,0); Point c=Point(lim,lim); Point d=Point(0,lim); l[++n]=Line(a,b); l[++n]=Line(b,c); l[++n]=Line(c,d); l[++n]=Line(d,a); if(!SI(l,n,p,m))return 0; return area(p,m);&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; Point a,b; scanf("%lf%lf%lf%lf",&amp;a.x,&amp;a.y,&amp;b.x,&amp;b.y); l[i]=Line(a,b); &#125; printf("%.1f\n",solve());&#125;]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>半平面交</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[凸包]]></title>
    <url>%2Fpost%2F%E5%87%B8%E5%8C%85%2F</url>
    <content type="text"><![CDATA[用不严谨的话来讲，给定二维平面上的点集，凸包就是将最外层的点连接起来构成凸多边形，它能包含点集中所有的点。 构造方法需要牢记的是 若 $a × b&gt;0$ 则 $a$ 在 $b$ 的顺时针方向 若 $a × b=0$ 则 $a$ 与 $b$ 共线 若 $a × b&gt;0$ 则 $a$ 在 $b$ 的逆时针方向 ①极角排序选择一个点作为基础点，进行极角排序。 可以通过比较叉积的方式进行极角排序，若叉积相同，则离基础点近的点优先级高。 1234567Point Base;bool cmp_ang(const Point &amp;a,const Point &amp;b)&#123; int tmp=dcmp(cross(a-Base,b-Base)); if(tmp==0)return dist(Base,a)&lt;dist(Base,b); else return tmp&gt;0;&#125; ②构造凸包从左下逆时针构造凸包，若这样构造那么只需要判断，栈顶的点，与当前加入的点，和栈中第二个点构成的向量，那个更靠外侧（那个处于另一个的顺时针方向），若当前加入的点更优，就将之前的点出栈。 时间复杂度 $O(n)$ 12345678910for(int i=1;i&lt;=num;i++) if(s[i]&lt;s[1])swap(s[1],s[i]);sort_point(s,2,num,s[1]);cnt=2;node[1]=s[1],node[2]=s[2];for(int i=3;i&lt;=num;i++)&#123; while(cnt&gt;=2&amp;&amp;dcmp(cross(node[cnt]-node[cnt-1],s[i]-node[cnt-1]))&lt;=0)cnt--; node[++cnt]=s[i];&#125; ③判断一个多边形是否是凸包方法一：根据多边形的点构造一个凸包，看是否与原多边形相等。 方法二：顺时针，或者逆时针检查每两条线段的叉积的正负情况，如果有正有负，则不是凸包。 123456789101112131415bool is_convex_hull()&#123; bool s[3]; memset(s,0,sizeof(s)); for(int i=1;i&lt;cnt-1;i++) &#123; s[dcmp(cross(node[i+1]-node[i],node[i+2]-node[i]))+1]=true; if(s[0]&amp;&amp;s[2])return false; &#125; s[dcmp(cross(node[cnt-1]-node[cnt-2],node[cnt]-node[cnt-2]))+1]=true; s[dcmp(cross(node[cnt]-node[cnt-1],node[1]-node[cnt-1]))+1]=true; s[dcmp(cross(node[1]-node[cnt],node[2]-node[cnt]))+1]=true; if(s[0]&amp;&amp;s[2])return false; return true;&#125; ④判断一个点是否在凸包内部方法一（只适用于凸包）：判断点是否在凸包每个角的中间（运用叉积判断）。 方法二（适用于所有多边形）：引一条射线，判断射线与多边形交点个数，若为奇数个则，在多边形内部，否则在边上，或者外面。 123456789101112131415161718192021222324int is_in_polygon(Point a)&#123; Line ray;//射线 ray.s=a; ray.e=Vector(-100000000.0,a.y); int ans=0; for(int i=1;i&lt;=cnt;i++) &#123; Point s1=edge[i].s,s2=edge[i].e; if(on_seg(a,edge[i]))return 0;//若a在边上返回0 if(dcmp(s1.y-s2.y)==0)continue;//若平行无视这条边 if(on_seg(s1,ray))//若上端点在射线上取上端点 &#123; if(dcmp(s1.y-s2.y)&gt;0)ans++; &#125; else if(on_seg(s2,ray))//同理 &#123; if(dcmp(s2.y-s1.y)&gt;0)ans++; &#125; else if(is_cross(ray,edge[i]))ans++;//判断线段与线段是否相交 &#125; if(ans%2==1)return 1; return -1;&#125; 里面用到了两个函数现在给出它们的实现方法 判断点是否在线段上，首先判断点是否在直线上，然后判断点的左边范围，是否符合线段的条件 12345bool on_seg(Point a,Segment a1)&#123; Point b=a1.s,c=a1.e; return dcmp(cross(b-a,c-a))==0&amp;&amp;min(b.x,c.x)&lt;=a.x&amp;&amp;a.x&lt;=max(b.x,c.x)&amp;&amp;min(b.y,c.y)&lt;=a.y&amp;&amp;a.y&lt;=max(b.y,c.y);&#125; 首先检查点的跨立情况，然后处理特殊情况（两条直线重合） 事实证明快速排斥，只是用来加快判断速度（对正确性并无影响） 如果说是规范相交去掉后面的四个判断（判断两条直线重合） 1234567891011121314bool is_cross(Line a1,Line a2)&#123; Point a=a1.s,b=a1.e,c=a2.s,d=a2.e; int c1=dcmp(cross(b-a,c-a)); int c2=dcmp(cross(b-a,d-a)); int o1=dcmp(cross(d-c,b-c)); int o2=dcmp(cross(d-c,a-c)); if(c1*c2&lt;=0&amp;&amp;o1*o2&lt;=0)return true; if(c1==0&amp;&amp;on_seg(c,a1))return true; if(c2==0&amp;&amp;on_seg(d,a1))return true; if(o1==0&amp;&amp;on_seg(b,a2))return true; if(o2==0&amp;&amp;on_seg(a,a2))return true; return false;&#125; ⑤判断圆是否在凸包内部先判断圆心是否在凸包内部，然后判断圆心到凸包每条边的最近点的距离是否小于圆的半径。 1234567bool circle_is_in_convex_hull(Circle a)&#123; if(is_in_polygon(a.O)&lt;0)return false; for(int i=1;i&lt;=cnt;i++) if(dcmp(dist(a.O,get_nearest_point_on_segment(a.O,edge[i]))+eps-a.R)&lt;0)return false; return true;&#125; 下面给出求点离线段的最近点的函数 求最近点有三种情况 最近点为左端点 最近点为右端点 最近点在线段中间 我们可以通过点乘，求出交点到左端点的距离，占线段总长度的比例。 dot(a-b,c-b)/dot(c-b,c-b) 即为 $a·b$ =$cos\theta|a||b|/(|b|^2)=cos\theta|a|:|b|$ $cos\theta|a|$ 的意义不言而喻。 12345678Point get_nearest_point_on_segment(Point a,Line a1)&#123; Point b=a1.s,c=a1.e; double t=dot(a-b,c-b)/dot(c-b,c-b); if(dcmp(t)!=-1&amp;&amp;dcmp(1-t)!=-1)return Vector(b.x+(c.x-b.x)*t,b.y+(c.y-b.y)*t); if(dist(a,b)&lt;dist(a,c))return b; return c;&#125; ⑥动态凸包运用splay维护凸包（待填坑，若想了解，可以发表评论）]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国剩余定理+扩展]]></title>
    <url>%2Fpost%2F%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86-%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[求 $x$ 的解 \begin{cases} x \equiv c_1 \pmod{m_1}\\ x \equiv c_2 \pmod{m_2}\\ x \equiv c_3 \pmod{m_3}\\ \cdots \\ x \equiv c_k \pmod{m_k}\\ \end{cases}其中满足$(m_i,m_j)=1,1&lt;=i≠j&lt;=k$ ans=\sum_{i=1}^{k} c_i\times\cfrac{M}{m_i}\times inv(\cfrac{M}{m_i},m_i)证明+运算过程设 $n_i\equiv0\pmod{\cfrac{M}{m_i}}$ 且 $n_i\equiv1\pmod{m_i}$ 则 $ ans=\sum_{i=1}^{n} c_i\times n_i$ 所以 $n_i=\cfrac{M}{m_i}\times x=m_i\times y+1$ 可得 $\cfrac{M}{m_i}\times x-m_i\times y=1$ 变化得 $\cfrac{M}{m_i}\times x\equiv1\pmod{m_i}$ 即 $x$ 为 $ \cfrac{M}{m_i}$ 在 $mod \ m_i$ 时的逆元 则我们可以使用 扩展GCD（费马小定理）求得 $x$ 则 $ ans=\sum_{i=1}^{k} c_i\times \cfrac{M}{m_i}\times x$ 简洁代码（适用于 $m_i$ 为质数）12345678910long long CRT()&#123; long long tot=0; for(int i=1;i&lt;=cnt;i++) &#123; tot+=ans[i]*(M/m[i])%M*Pow(M/m[i],m[i]-2,m[i])%M; tot%=M; &#125; return tot;&#125; 一般的代码123456789101112long long CRT()&#123; long long tot=0; for(int i=1;i&lt;=cnt;i++) &#123; exgcd(M/m[i],m[i],x,y); x=(x%m[i]+m[i])%m[i]; tot+=ans[i]*(M/m[i])%M*x%M; tot%=M; &#125; return tot;&#125; 扩展 中国剩余定理 \begin{cases} x \equiv c_1 \pmod{m_1}\\ x \equiv c_2 \pmod{m_2}\\ x \equiv c_3 \pmod{m_3}\\ \cdots \\ x \equiv c_k \pmod{m_k}\\ \end{cases}主要使用了扩展GCD 考虑使用扩展GCD合并两个方程组 \begin{cases} x \equiv c_1 \pmod{m_1} \\ x \equiv c_2 \pmod{m_2} \\ \end{cases}则可得 \begin{cases} x=c_1+m_1k_1\\ x=c_2+m_2k_2\\ \end{cases}得 $c_1+m_1k_1=c_2+m_2k_2$ 移项得 $m_1k_1=c_2-c_1+m_2k_2$ 若 $(m_1,m_2)|(c_2-c_1)$ 则有解 将方程两边同时除以 $(m_1,m_2)$ 得$\cfrac{m1}{(m_1,m_2)}k_1\equiv\cfrac{c_2-c_1}{(m_1,m_2)}\pmod{\cfrac{m_2}{(m_1,m_2)}}$ 将两边同时除以 $\cfrac{m_1}{(m_1,m_2)}$ 得$k_1\equiv inv(\cfrac{m_1}{(m_1,m_2)},\cfrac{m_2}{(m_1,m_2)})\times\cfrac{c_2-c_1}{(m_1,m_2)}\pmod{\cfrac{m_2}{(m_1,m_2)}}$ 转换得到 k_1= inv(\cfrac{m_1}{(m_1,m_2)},\cfrac{m_2}{(m_1,m_2)})\times\cfrac{c_2-c_1}{(m_1,m_2)}+y\times\cfrac{m_2}{(m_1,m_2)}将 $k_1$ 代换成 $\cfrac{x-c_1}{m_1}$ 得 $x= inv(\cfrac{m_1}{(m_1,m_2)},\cfrac{m_2}{(m_1,m_2)})\times\cfrac{c_2-c_1}{(m_1,m_2)}\times m_1+y\times\cfrac{m_1m_2}{(m_1,m_2)}+c_1$转换得到 x\equiv inv(\cfrac{m_1}{(m_1,m_2)},\cfrac{m_2}{(m_1,m_2)})\times\cfrac{c_2-c_1}{(m_1,m_2)}\% \cfrac{m_2}{(m_1,m_2)}\times m_1+c_1 \pmod{\cfrac{m_1m_2}{(m_1,m_2)}}至此我们就将两个方程合并为了一个同余方程 在右边的所有项均已知只需要求得答案便可以了 123456789101112long long EXCRT()&#123; for(int i=2;i&lt;=n;i++) &#123; long long m1=m[i-1],m2=m[i],c1=c[i-1],c2=c[i],GCD=gcd(m1,m2); if((c2-c1)%GCD)return -1; m[i]=m1/GCD*m2; c[i]=inv(m1/GCD,m2/GCD)*(c2-c1)/GCD%(m2/GCD)*m1+c1; c[i]=(c[i]%m[i]+m[i])%m[i]; &#125; return c[n];&#125;]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>CRT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The LCIS on the Tree]]></title>
    <url>%2Fpost%2FThe%20LCIS%20on%20the%20Tree%2F</url>
    <content type="text"><![CDATA[【题目大意】给出一棵树，树上的每个点有权值，$m$ 次询问从 $u$ 到 $v$ 两点路径上最大的 $LCIS$ 值是多少 【解题思路】因为LCIS必须连续所以我们可以考虑用线段树的合并来做我是这么处理这个过程的，对于每个区间，记录每个区间的 $Lval$（左端点值）,$Rval$（右端点值），$LL$（以左端点为起点的下降最大LCIS值）,$LR$（以左端点为起点的上升最大LCIS值）,$RL$（以右端点为终点的下降最大LCIS值）,$RR$（同上），$Len$（区间内从左到右的最长上升LCIS值）,$Ren$（从右到左最长上升LCIS值），那么在区间合并时去维护这几个值就可以了，在爬树过程中直接进行合并操作。 【AC代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=300010;struct edge&#123; int v,next;&#125;e[maxn*2];int head[maxn],cnt=0,val[maxn],dep[maxn],fa[maxn],to[maxn],rnk[maxn],N=0,son[maxn],size[maxn],top[maxn];void add(int u,int v)&#123; e[++cnt]=(edge)&#123;v,head[u]&#125;; head[u]=cnt; e[++cnt]=(edge)&#123;u,head[v]&#125;; head[v]=cnt; &#125;void Init()&#123; memset(head,-1,sizeof(head)); memset(son,-1,sizeof(son)); cnt=0; N=0;&#125;void dfs1(int u,int fath)&#123; fa[u]=fath; size[u]=1; dep[u]=dep[fath]+1; for(int i=head[u];~i;i=e[i].next) &#123; int v=e[i].v; if(v==fath)continue; dfs1(v,u); size[u]+=size[v]; if(son[u]==-1||size[son[u]]&lt;size[v])son[u]=v; &#125; return ;&#125;void dfs2(int u,int tp)&#123; to[u]=++N; rnk[N]=u; top[u]=tp; if(son[u]==-1)return; dfs2(son[u],tp); for(int i=head[u];~i;i=e[i].next) &#123; int v=e[i].v; if(son[u]==v||fa[u]==v)continue; dfs2(v,v); &#125;&#125;struct tree&#123; int l,r; int Rval,Lval; int LL,RR,LR,RL; int Len,Ren; tree() &#123; Len=Ren=0; LL=LR=RL=RR=0; Lval=Rval=0; &#125;; &#125;tr[maxn&lt;&lt;1];tree merge(tree A,tree B)&#123; if(B.Len==0)return A; tree sum=A; sum.r=B.r; sum.Rval=B.Rval; sum.Len=max(A.Len,B.Len); sum.Ren=max(A.Ren,B.Ren); if(A.LR==A.r-A.l+1&amp;&amp;A.Rval&lt;B.Lval)sum.LR=A.LR+B.LR; else sum.LR=A.LR; if(A.LL==A.r-A.l+1&amp;&amp;A.Rval&gt;B.Lval)sum.LL=A.LL+B.LL; else sum.LL=A.LL; if(B.RL==B.r-B.l+1&amp;&amp;A.Rval&gt;B.Lval)sum.RL=A.RL+B.RL; else sum.RL=B.RL; if(B.RR==B.r-B.l+1&amp;&amp;A.Rval&lt;B.Lval)sum.RR=A.RR+B.RR; else sum.RR=B.RR; sum.Ren=max(sum.Ren,sum.LL); sum.Ren=max(sum.Ren,sum.RL); sum.Len=max(sum.Len,sum.LR); sum.Len=max(sum.Len,sum.RR); if(A.Rval&lt;B.Lval)sum.Len=max(sum.Len,A.RR+B.LR); if(A.Rval&gt;B.Lval)sum.Ren=max(sum.Ren,A.RL+B.LL); return sum;&#125;void build(int l,int r ,int rt)&#123; tr[rt].l=l; tr[rt].r=r; if(l==r) &#123; tr[rt].LL=tr[rt].RL=tr[rt].RR=tr[rt].LR=1; tr[rt].Lval=tr[rt].Rval=val[rnk[l]]; tr[rt].Ren=tr[rt].Len=1; return; &#125; int mid=l+r&gt;&gt;1; build(l,mid,rt&lt;&lt;1); build(mid+1,r,rt&lt;&lt;1|1); tr[rt]=merge(tr[rt&lt;&lt;1],tr[rt&lt;&lt;1|1]);&#125;tree query(int L,int R,int rt)&#123; int l=tr[rt].l,r=tr[rt].r; if(L==l&amp;&amp;R==r)return tr[rt]; int mid=l+r&gt;&gt;1; if(R&lt;=mid)return query(L,R,rt&lt;&lt;1); else if(L&gt;mid)return query(L,R,rt&lt;&lt;1|1); else return merge(query(L,mid,rt&lt;&lt;1),query(mid+1,R,rt&lt;&lt;1|1));&#125;int Query(int u,int v)&#123; bool flag=0; int ut=top[u],vt=top[v]; tree ans1=tree(),ans2=tree(); while(ut!=vt) &#123; if(dep[ut]&lt;dep[vt]) &#123; flag^=1; swap(ut,vt); swap(u,v); swap(ans1,ans2); &#125; ans1=merge(query(to[ut],to[u],1),ans1); u=fa[ut]; ut=top[u]; &#125; if(dep[u]&gt;dep[v])flag^=1,swap(u,v),swap(ans1,ans2); ans2=merge(query(to[u],to[v],1),ans2); if(flag)swap(ans1,ans2); int ans=max(ans1.Ren,ans2.Len); if(ans1.Lval&lt;ans2.Lval)ans=max(ans2.LR+ans1.LL,ans); return ans;&#125;int n,u,Q;int main()&#123; int T,t=0,fuck_PE=0; scanf("%d",&amp;T); while(T--) &#123; Init(); t++; if(fuck_PE)printf("\n"); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)scanf("%d",&amp;val[i]); for(int i=2;i&lt;=n;i++) &#123; scanf("%d",&amp;u); add(u,i); &#125; dfs1(1,0); dfs2(1,1); build(1,n,1); scanf("%d",&amp;Q); printf("Case #%d:\n",t); while(Q--) &#123; int v; scanf("%d%d",&amp;u,&amp;v); printf("%d\n",Query(u,v)); &#125; fuck_PE=1; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AC自动机]]></title>
    <url>%2Fpost%2FAC%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[AC自动机：Aho-Corasickautomation，该算法在1975年产生于贝尔实验室，是著名的多模匹配算法之一。一个常见的例子就是给出n个单词，再给出一段包含m个字符的文章，让你找出有多少个单词在文章里出现过。 AC自动机算法分为3步：构造一棵Trie树，构造失败指针和模式匹配过程。简单来说，AC自动机是用来进行多模式匹配（单个主串，多个模式串）的高效算法。 首先你得先了解KMP和Trie两种算法然后就可以构建AC自动机了 123456789101112131415161718struct AC_automaton&#123; int son[maxn][26],val[maxn]; int fail[maxn],last[maxn]; int size; void clear() &#123; memset(son[0],0,sizeof(son[0]));size=1; &#125; void clear_p(int x) &#123; memset(son[x],0,sizeof(son[x])); val[x]=0; &#125; int make(char x) &#123; return x-'a'; &#125; 加入字符串方法与 $Trie$ 相同12345678910111213141516void insert(char *s)&#123; int u=0; int len=strlen(s); for(int i=0;i&lt;len;i++) &#123; int c=make(s[i]); if(!son[u][c]) &#123; clear_p(size); son[u][c]=size++; &#125; u=son[u][c]; &#125; val[u]++;&#125; 处理 $fail,last$ 指针 这里的 $fail$ 与 $KMP$ 中的 $next$ 十分相似，都是在失配的时候利用之前的信息达到快速匹配的目的。 $last$ 主要用于处理字符串包含的情况。 1234567891011121314151617181920212223242526272829303132333435void getfail()&#123; queue&lt;int&gt;q; fail[0]=0; int u=0; for(int i=0;i&lt;26;i++) &#123; u=son[0][i]; if(u) &#123; fail[u]=0; last[u]=0; q.push(u); &#125; &#125; while(!q.empty()) &#123; int r=q.front(); q.pop(); for(int i=0;i&lt;26;i++) &#123; u=son[r][i]; if(!u) &#123; son[r][i]=son[fail[r]][i]; continue; &#125; q.push(u); int v=fail[r]; while(v&amp;&amp;!son[v][i])v=fail[v]; fail[u]=son[v][i]; last[u]=val[fail[u]]?fail[u]:last[fail[u]]; &#125; &#125;&#125; 查找字符串的匹配情况1234567891011121314151617181920 int find(char *s) &#123; int u=0,cnt=0; int len=strlen(s); for(int i=0;i&lt;len;i++) &#123; int c=make(s[i]); u=son[u][c]; int temp=0; if(val[u])temp=u; else if(last[u])temp=last[u]; while(temp) &#123; cnt+=val[temp]; temp=last[temp]; &#125; &#125; return cnt; &#125;&#125;AC; 至此AC自动机就被构建完成了]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树]]></title>
    <url>%2Fpost%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[假设有编号从1到n的n个点，每个点都存了一些信息，用[L,R]表示下标从L到R的这些点。线段树的用处就是，对编号连续的一些点进行修改或者统计操作，修改和统计的复杂度都是 $O(log2(n))$.线段树的原理就是将[1,n]分解成若干特定的子区间(数量不超过 $4n$ ),然后，将每个区间[L,R]都分解为少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]的修改或者统计。由此看出，用线段树统计的东西，必须符合区间加法，否则，不可能通过分成的子区间来得到[L,R]的统计结果。 符合区间加法的例子： $数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和$$最大值——总最大值=max(左区间最大值，右区间最大值)$ 代码区间和区间修改（乘，加）建树注: $begin$ 为初始数组. 12345678910111213141516void build(int l,int r,int rt)&#123; t[rt].l=l; t[rt].r=r; t[rt].mul=1; t[rt].add=0; if(l==r) &#123; t[rt].sum=begin[l]%mod; return ; &#125; int mid=(l+r)&gt;&gt;1; build(l,mid,rt&lt;&lt;1); build(mid+1,r,rt&lt;&lt;1|1); pushup(rt);&#125; pushup操作1234void pushup(int rt)&#123; t[rt].sum=(t[rt&lt;&lt;1].sum+t[rt&lt;&lt;1|1].sum)%mod;&#125; pushdown操作12345678910111213void pushdonw(int rt)&#123; int l=t[rt].l,r=t[rt].r,m=(l+r)&gt;&gt;1,lc=rt&lt;&lt;1,rc=rt&lt;&lt;1|1; t[lc].sum=(t[lc].sum*t[rt].mul%mod+t[rt].add*(m-l+1))%mod; t[rc].sum=(t[rc].sum*t[rt].mul%mod+t[rt].add*(r-m))%mod; t[lc].mul=(t[lc].mul*t[rt].mul)%mod; t[rc].mul=(t[rc].mul*t[rt].mul)%mod; t[lc].add=(t[lc].add*t[rt].mul+t[rt].add)%mod; t[rc].add=(t[rc].add*t[rt].mul+t[rt].add)%mod; t[rt].add=0; t[rt].mul=1; return ;&#125; 在此说明一下根据我们规定的优先度儿子的值=此刻儿子的值 $\times$ 爸爸的乘法lazy+儿子长度 $\times$ 爸爸的加法lazy这样进行计算就好了 区间加法12345678910111213141516void op_add(int rt,int L,int R,long long c)&#123; int l=t[rt].l,r=t[rt].r; if(l&gt;R||r&lt;L)return; if(l&gt;=L&amp;&amp;r&lt;=R) &#123; t[rt].add=(t[rt].add+c)%mod; t[rt].sum=(t[rt].sum+(r-l+1)*c)%mod; return ; &#125; pushdown(rt); op_add(rt&lt;&lt;1,L,R,c); op_add(rt&lt;&lt;1|1,L,R,c); pushup(rt); return;&#125; 区间乘法1234567891011121314151617void op_mul(int rt,int L,int R,long long c)&#123; int l=t[rt].l,r=t[rt].r; if(l&gt;R||r&lt;L)return; if(l&gt;=L&amp;&amp;r&lt;=R) &#123; t[rt].mul=(t[rt].mul*c)%mod; t[rt].sum=(t[rt].sum*c)%mod; t[rt].add=(t[rt].add*c)%mod; return ; &#125; pushdown(rt); op_mul(rt&lt;&lt;1,L,R,c); op_mul(rt&lt;&lt;1|1,L,R,c); pushup(rt); return;&#125; 查询区间和12345678void query(int rt,int L,int R)&#123; int l=t[rt].l,r=t[rt].r; if(l&gt;R||r&lt;L)return 0; if(l&gt;=L&amp;&amp;r&lt;=R)return t[rt].sum; pushdown(rt); return (query(rt&lt;&lt;1,L,R)+query(rt&lt;&lt;1|1,L,R))%mod;&#125; AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int MAX=100020,inf=1&lt;&lt;30;long long mod;struct tree&#123; long long sum,add,mul; int l,r;&#125;t[MAX*4];long long begin[MAX];int n,m;void pushup(int rt)&#123; t[rt].sum=(t[rt&lt;&lt;1].sum+t[rt&lt;&lt;1|1].sum)%mod;&#125;void build(int l,int r,int rt)&#123; t[rt].l=l; t[rt].r=r; t[rt].mul=1; t[rt].add=0; if(l==r) &#123; t[rt].sum=begin[l]%mod; return ; &#125; int mid=(l+r)&gt;&gt;1; build(l,mid,rt&lt;&lt;1); build(mid+1,r,rt&lt;&lt;1|1); pushup(rt);&#125;void pushdown(int rt)&#123; int l=t[rt].l,r=t[rt].r; int m=(l+r)&gt;&gt;1,lc=rt&lt;&lt;1,rc=rt&lt;&lt;1|1; t[lc].sum=(t[lc].sum*t[rt].mul%mod+t[rt].add*(m-l+1))%mod; t[rc].sum=(t[rc].sum*t[rt].mul%mod+t[rt].add*(r-m))%mod; t[lc].mul=(t[lc].mul*t[rt].mul)%mod; t[rc].mul=(t[rc].mul*t[rt].mul)%mod; t[lc].add=(t[lc].add*t[rt].mul+t[rt].add)%mod; t[rc].add=(t[rc].add*t[rt].mul+t[rt].add)%mod; t[rt].add=0; t[rt].mul=1; return ;&#125;void op_add(int rt,int L,int R,long long c)&#123; int l=t[rt].l,r=t[rt].r; if(l&gt;R||r&lt;L)return; if(l&gt;=L&amp;&amp;r&lt;=R) &#123; t[rt].add=(t[rt].add+c)%mod; t[rt].sum=(t[rt].sum+(r-l+1)*c)%mod; return ; &#125; pushdown(rt); op_add(rt&lt;&lt;1,L,R,c); op_add(rt&lt;&lt;1|1,L,R,c); pushup(rt); return;&#125;void op_mul(int rt,int L,int R,long long c)&#123; int l=t[rt].l,r=t[rt].r; if(l&gt;R||r&lt;L)return; if(l&gt;=L&amp;&amp;r&lt;=R) &#123; t[rt].mul=(t[rt].mul*c)%mod; t[rt].sum=(t[rt].sum*c)%mod; t[rt].add=(t[rt].add*c)%mod; return ; &#125; pushdown(rt); op_mul(rt&lt;&lt;1,L,R,c); op_mul(rt&lt;&lt;1|1,L,R,c); pushup(rt); return;&#125;long long query(int rt,int L,int R)&#123; int l=t[rt].l,r=t[rt].r; if(l&gt;R||r&lt;L)return 0; if(l&gt;=L&amp;&amp;r&lt;=R)return t[rt].sum; pushdown(rt); return (query(rt&lt;&lt;1,L,R)+query(rt&lt;&lt;1|1,L,R))%mod;&#125;int main()&#123; scanf("%d%d%lld",&amp;n,&amp;m,&amp;mod); for(int i=1;i&lt;=n;i++)scanf("%lld",&amp;begin[i]); build(1,n,1); for(int i=1;i&lt;=m;i++) &#123; int op; int x,y;long long k; scanf("%d",&amp;op); switch(op) &#123; case 1:scanf("%d%d%lld",&amp;x,&amp;y,&amp;k);op_mul(1,x,y,k);break; case 2:scanf("%d%d%lld",&amp;x,&amp;y,&amp;k);op_add(1,x,y,k);break; case 3:scanf("%d%d",&amp;x,&amp;y);printf("%lld\n",query(1,x,y)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
</search>
